<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VideoFrames: Tag & Extract</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
/* Variables */
:root {
    --bg-color: #1d1c1c;
    --text-color: #e0e0e0;
    --primary-color: #226b9c;
    --primary-hover-color: #3498db;
    --secondary-color: #1d8147;
    --secondary-hover-color: #12b356;
    --third-color: #b17a2b;
    --third-hover-color: #cf931e;
    --fourth-color: #921b1b;
    --fourth-hover-color: #d42a2a;
    --disabled-color: #4a4a4a;
    --timeline-bg: #2c3e50;
    --timeline-indicator: #3498db;
    --timeline-indicator-hover: #acdeff;
    --timeline-indicator-active: #ff0000;
    --crop-handle-size: 10px;
    --crop-handle-color: #3498db;
    --crop-overlay-color: rgba(0, 0, 0, 0.5);
    --modal-bg: #1d1c1c;
    --modal-border: #3a3a3a;
    --input-bg: #2a2a2a;
    --input-border: #3a3a3a;
    --input-focus: #226b9c;
}

/* Global Styles */
html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
}

body {
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
}

h1, h2 {
    color: var(--primary-color);
    text-align: center;
    text-shadow: 0px 0px 20px #000000
}
h3 {
    background: linear-gradient(45deg, var(--primary-color) 40%, var(--secondary-color) 60%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-align: center;
    text-shadow: 0px 0px 20px #ffffff24;
    background-clip: text;

}

/* Sidebar Styles */
#sidebar {
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    background-color: var(--bg-color);
    box-shadow: 2px 0 19px 3px rgba(0, 0, 0, 0.25);
    z-index: 1000;
    display: flex;
    flex-direction: column;
    height: 100vh;
}

#sidebar.collapsed {
    transform: translateX(-140px);
}

#sidebarToggle {
    position: absolute;
    right: -42px;
    top: 10px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 10px;
    cursor: pointer;
    border-radius: 0 5px 5px 0;
    height: 40px;
    transition: all .2s;
}

#sidebarToggle:hover {
    box-shadow: inset 0px 0px 4px 1px #78b3dc, 4px 0px 12px 2px #1b4664;
}

.sidebar-item {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
}

.sidebar-item button,
.sidebar-item label {
    width: 100%;
    padding: 12px 20px;
    border: none;
    border-radius: 5px;
    color: white;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0px;
    text-shadow: 0 0 5px #000000c9;
}

.sidebar-item:nth-child(3) button { background-color: var(--third-color); }
.sidebar-item:nth-child(3) button:hover { background-color: var(--third-hover-color); }

.sidebar-item:nth-child(4) button { background-color: var(--fourth-color); }
.sidebar-item:nth-child(4) button:hover { background-color: var(--fourth-color); }

.sidebar-item:nth-child(5) button { background-color: var(--primary-color); }
.sidebar-item:nth-child(5) button:hover { background-color: var(--primary-color); }

.sidebar-item:nth-child(6) button { background-color: var(--secondary-color); }
.sidebar-item:nth-child(6) button:hover { background-color: var(--secondary-hover-color); }

.sidebar-item button:hover,
.sidebar-item label:hover {
    transform: translateY(-2px);
}

.sidebar-item input[type="file"] {
    display: none;
}

/* Main Content Styles */
#mainContent {
    margin-left: 140px;
    width: calc(100% - 250px);
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-grow: 1;
    height: 100vh;
    box-sizing: border-box;
}

#mainContent.expanded {
    margin-left: 0;
    width: 100%;
}

/* Video Player Styles */
#videoContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 1200px;
    position: relative;
    margin: 0 auto;
}

.video-wrapper {
    position: relative;
    width: fit-content;
    height: fit-content;
    display: flex;
    justify-content: center;
    align-items: center;
}

#videoPlayer {
    display: block;
    max-width: 100%;
    height: auto;
    object-fit: contain;
}

#frameInfo {
    display: none;
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 10;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 14px;
}

/* Timeline Styles */
#timeline {
    width: 100%;
    height: 30px;
    background-color: var(--timeline-bg);
    position: relative;
    cursor: pointer;
    margin-top: 10px;
    overflow: hidden;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    border-radius: 5px;
    display: none;
}

#progressLine {
    position: absolute;
    height: 100%;
    background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
    top: 0;
    left: 0;
    width: 0%;
    z-index: 1;
}

#scrubber {
    position: absolute;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: #fff;
    top: 50%;
    transform: translate(-50%, -50%);
    left: 0;
    cursor: pointer;
    z-index: 2;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    transition: transform 0.1s ease;
}

#scrubber:hover {
    transform: translate(-50%, -50%) scale(1.2);
}

.screenshot-indicator {
    position: absolute;
    width: 4px;
    height: 100%;
    background-color: var(--timeline-indicator);
    transition: background-color 0.3s ease;
    cursor: pointer;
    z-index: 3;
    box-shadow: inset 0px 0px 2px 0px #ffffff69, inset 0px 0px 3px #3c7eff;
}

.screenshot-indicator:hover,
.screenshot-indicator.active {
    background-color: var(--timeline-indicator-active);
    width: 6px;
    box-shadow: 0px 0px 6px #0000008c, inset 0px 0px 1px 1px #ff9393;
    border-radius: 10px;
}

/* Control Styles */
button {
    background-color: var(--secondary-color);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    margin: 10px;
    transition: background-color 0.3s ease;
}

button:disabled {
    background-color: var(--disabled-color) !important;
    cursor: not-allowed;
}

#addFrameButton {
    margin-right: 10px;
    text-shadow: 0 0 5px #000000c9;
    font-size: small;
    transition: all 0.3s;
}

#addFrameButton:hover {
    transform: translateY(-2px);
}

/* Output Styles */
#output {
    margin-top: 20px;
    padding: 10px;
    background-color: var(--timeline-bg);
    border-radius: 5px;
    color: var(--text-color);
    width: fit-content;
    margin: 10px auto;
    display: none;
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1001;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.4);
    backdrop-filter: blur(5px);
}

.modal-content {
    background-color: var(--modal-bg);
    margin: 100px auto;
    padding: 25px;
    border: 1px solid var(--modal-border);
    border-radius: 10px;
    width: 500px;
    max-width: 90%;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    position: relative;
    box-sizing: border-box;
}

.export-modal-header {
    text-align: center;
    margin-bottom: 25px;
}

.export-modal-header h3 {
    font-size: 24px;
    margin: 0;
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.export-section {
    margin-bottom: 20px;
    padding: 15px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    border: 1px solid var(--input-border);
    box-sizing: border-box;
}

.export-section label {
    display: block;
    margin-bottom: 8px;
    color: var(--text-color);
    font-weight: bold;
}

.export-section input {
    width: 100%;
    padding: 10px;
    background: var(--input-bg);
    border: 1px solid var(--input-border);
    border-radius: 5px;
    color: var(--text-color);
    font-size: 14px;
    transition: all 0.3s ease;
    box-sizing: border-box;
}

.export-section input:focus {
    outline: none;
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 2px rgba(46, 204, 113, 0.3);
}

.dimensions-display {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 15px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
}

.dimensions-box {
    flex: 1;
    padding: 8px;
    text-align: center;
}

.dimensions-box p {
    margin: 5px 0;
    font-size: 14px;
}

.dimensions-box .dim-label {
    color: var(--primary-color);
    font-weight: bold;
    font-size: 12px;
    text-transform: uppercase;
}

.dimensions-box .dim-label-new {
    color: var(--secondary-color);
    font-weight: bold;
    font-size: 12px;
    text-transform: uppercase;
}

.dimensions-box .dim-value {
    color: var(--text-color);
    font-family: monospace;
    font-size: 16px;
}

.scale-factor-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 15px;
}

.scale-factor-container input {
    width: 80px;
    flex-shrink: 0;
}

.scale-factor-container label {
    margin-bottom: 0;
    white-space: nowrap;
}

.scale-factor-container span {
    color: var(--text-color);
    opacity: 0.7;
    font-size: 14px;
}

.export-buttons {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}

.export-button {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 5px;
    color: white;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
}

#exportFramesOnly {
    background-color: var(--secondary-color);
}

#exportFramesWithSession {
    background-color: var(--primary-color);
}

.export-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

/* Tag Manager Styles */
.tag-manager {
    margin-top: 10px;
}

.tag-manager input {
    width: -webkit-fill-available;
    width: -moz-available;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid var(--disabled-color);
    border-radius: 5px;
    background-color: var(--bg-color);
    color: var(--text-color);
    font-size: 14px;
}

.tag-manager input:focus {
    outline: none;
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 2px rgba(46, 204, 113, 0.3);
}

.tag-list {
    max-height: 150px;
    overflow-y: auto;
}

.tag-item {
    display: inline-flex;
    align-items: center;
    background-color: var(--secondary-color);
    color: white;
    padding: 5px 12px;
    border-radius: 15px;
    margin: 5px 15px 5px 0;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 12px;
    position: relative;
    min-height: 24px;
}

.tag-item:hover {
    z-index: 20;
    background-color: var(--secondary-hover-color);
    box-shadow: 0px 0px 0px 1px #39ff00, 0px 0px 4px 1px #39ff00;
}

.tag-item:hover .tag-reorder {
    opacity: 1;
    transform: translateY(-50%) scale(1);
    margin-left: -10px;
}

.tag-reorder {
    position: absolute;
    display: flex;
    align-items: center;
    gap: 4px;
    top: 50%;
    transform: translateY(-50%) scale(0.8);
    opacity: 0;
    transition: all 0.2s ease;
    padding: 2px;
    z-index: 10;
    background: rgba(0, 0, 0, 0.6);
    border-radius: 12px;
    backdrop-filter: blur(4px);
}

.tag-reorder button {
    background: none;
    border: none;
    color: var(--text-color);
    cursor: pointer;
    padding: 0px;
    margin: 0;
    font-size: 14px;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 20px;
    min-height: 20px;
    transition: all 0.2s ease;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.1);
}

.tag-reorder button:hover {
    color: var(--secondary-color);
    text-shadow: 0 0 5px var(--secondary-color);
    transform: scale(1.1);
    background: rgba(255, 255, 255, 0.2);
}

.tag-reorder.left {
    right: calc(100% + 4px);
    margin-right: 0;
    padding-right: 4px;
}

.tag-reorder.right {
    left: calc(100% + 4px);
    margin-left: 0;
    padding-left: 4px;
}

.delete-tag {
    margin-left: 8px;
    font-weight: bold;
    cursor: pointer;
    padding: 1px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.3s ease;
    font-size: 14px;
    opacity: 0;
    width: 12px;
    height: 12px;
}

.tag-item:hover .delete-tag {
    opacity: 1;
}

.delete-tag:hover {
    color: var(--fourth-hover-color);
    transform: scale(1.2);
    text-shadow: 0 0 10px var(--fourth-hover-color);
    background: rgba(255, 255, 255, 0.1);
}

/* Tag Overlay Styles */
#tagOverlay {
    display: none;
    flex-wrap: wrap;
    align-items: flex-start;
    justify-content: flex-start;
    border-radius: 5px;
    margin-left: 10px;
    flex: 1;
    min-height: 40px;
    max-height: 70px;
    overflow-y: scroll;
    margin-top: -5px;
}

.tag-overlay-item {
    display: inline-flex;
    align-items: center;
    color: white;
    padding: 6px 10px;
    border-radius: 5px;
    margin: 3px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    font-size: small;
    border: 1px solid #226b9c7a;
    white-space: nowrap;
}

.tag-overlay-item:hover {
    background-color: var(--timeline-bg);
}

.tag-overlay-item.selected {
    background-color: #27ae6024;
    border: 1px solid var(--secondary-color);
    box-shadow: 0 0 0px 2px rgb(46 204 113 / 31%);
}

h2 {
    color: #DDD;
    font-family: 'Georgia', serif;
    font-style: italic;
    text-align: center;
    padding: 5px;
    background: linear-gradient(to right, transparent, #226b9c1f 20%, #226b9c1f 80%, transparent);
    position: relative;
}

h2::before,
h2::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(to right, transparent, var(--primary-color) 20%, var(--primary-color) 80%, transparent);
}

h2::before { top: 0; }
h2::after { bottom: 0; }

/* Bottom Controls Styles */
#bottomControls {
    display: none;
    justify-content: flex-start;
    align-items: flex-start;
    width: 100%;
    margin-top: 10px;
    min-height: 50px;
    max-height: 120px;
    overflow-y: auto;
    padding: 5px;
    gap: 10px;
    background: rgba(0, 0, 0, 0.05);
    border-radius: 5px;
}



#addFrameButton, #cropButton, #frameCounter {
    flex-shrink: 0;
    margin: 3px;
}

/* Header and Output Styles */
#mainContent h2 {
    margin: 0;
}

#output {
    display: none;
    margin-left: 20px;
    vertical-align: middle;
}

.header-output-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 10px;
}

/* Utility Classes */
.no-select {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

/* Bottom Right Controls */
#bottomRightControls {
    position: fixed;
    bottom: 10px;
    right: 10px;
    display: flex;
    z-index: 1000;
}

#helpButton,
#settingsButton {
    background-color: var(--primary-color);
    color: white;
    border: none;
    font-size: 24px;
    cursor: pointer;
    transition: background-color 0.3s ease;
    padding: 10px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

#helpButton:hover,
#settingsButton:hover {
    background-color: var(--primary-hover-color);
}

#helpButton svg,
#settingsButton svg {
    width: 24px;
    height: 24px;
    fill: currentColor;
}

#settingsButton {
    margin-right: 10px;
}

/* Help and Settings Modal Styles */
#helpModal,
#settingsModal {
    display: none;
    position: fixed;
    z-index: 1001;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
    backdrop-filter: blur(5px);
}

#settingsModal h2 {
    margin: 0;
}

.help-modal-content,
.settings-modal-content {
    background-color: var(--bg-color);
    padding: 25px;
    border: 1px solid var(--disabled-color);
    width: 60%;
    max-width: 600px;
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    max-height: 80vh;
    overflow-y: auto;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.help-modal-content h2,
.help-modal-content h3,
.settings-modal-content h3 {
    margin-top: 20px;
    margin-bottom: 10px;
}

.help-modal-content p, 
.help-modal-content ul, 
.help-modal-content ol {
    margin-bottom: 15px;
    line-height: 1.5;
}

.help-modal-content ul, 
.help-modal-content ol {
    padding-left: 20px;
}

.help-modal-content li {
    margin-bottom: 5px;
}

.help-modal-content strong {
    color: var(--primary-color);
}
.help-modal-content button {
    padding: 8px;
    cursor: auto;
}

/* Settings Styles */
.settings-group {
    margin-bottom: 20px;
}

.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.setting-item label {
    flex: 1;
    margin-right: 10px;
}

.setting-item input,
.setting-item select {
    flex: 1;
    padding: 8px;
    border-radius: 5px;
    border: 1px solid var(--disabled-color);
    background-color: var(--bg-color);
    color: var(--text-color);
    font-size: 14px;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.setting-item input:focus,
.setting-item select:focus {
    outline: none;
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 2px rgba(46, 204, 113, 0.3);
}

/* Help Button Styles */
.help-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 2px 8px;
    font-size: 0.8em;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: default;
    vertical-align: middle;
    margin: 0 4px;
}

.help-button-extract { background-color: var(--fourth-color); }
.help-button-sidebar,
.help-button-gear { background-color: var(--primary-color); }
.help-button-video,
.help-button-frame { background-color: var(--secondary-color); }
.help-button-tag { background-color: var(--third-color); }

.help-button svg {
    width: 16px;
    height: 16px;
    fill: currentColor;
}

/* Shortcut Key Styles */
.shortcut-key,
.shortcut-key_blank {
    background-color: #3a4559;
    color: white;
    padding: 2px 5px;
    border-radius: 3px;
    font-family: monospace;
    font-weight: bold;
}

.shortcut-input {
    font-family: monospace;
    font-weight: bold;
}

/* Animation Styles */
@keyframes buttonPulse {
    0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.7); }
    50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(0, 123, 255, 0); }
    100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0, 123, 255, 0); }
}

@keyframes tagMove {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); box-shadow: 0 0 15px 5px var(--primary-hover-color); }
    100% { transform: scale(1); }
}

.tag-move {
    animation: tagMove 0.5s ease-in-out;
}

.button-pulse {
    animation: buttonPulse 0.3s ease-in-out;
}

@keyframes glowingBorder {
    0% { box-shadow: inset 0 0 0 0px rgba(46, 204, 113, 0.7), 0 0 0 0px rgba(46, 204, 113, 0.7); }
    50% { box-shadow: inset 0 0 0 2px rgba(46, 204, 113, 1), 0 0 9px 0px rgba(46, 204, 113, 1); }
    100% { box-shadow: inset 0 0 0 0px rgba(46, 204, 113, 0.7), 0 0 0 0px rgba(46, 204, 113, 0.7); }
}

#uploadVideoButton {
    animation: glowingBorder 2s infinite;
    transition: all 0.3s;
}

#uploadVideoButton:hover {
    transform: translateY(-2px);
    background-color: #1d1c1c;
}



#uploadVideoButton.video-loaded {
    animation: none;
}

/* Video Placeholder Styles */
#videoPlaceholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 25%;
    border-radius: 8px;
    color: var(--text-color);
}

#videoPlaceholder svg {
    width: 100%;
    height: 100%;
    color: var(--primary-color);
}

#videoPlaceholder p {
    font-size: 16px;
    text-align: center;
    line-height: 1.5;
    margin: 0;
    opacity: 0.8;
}

/* Loading Indicator Styles */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(29, 28, 28, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
}

.spinner {
    border: 8px solid var(--disabled-color);
    border-top: 8px solid var(--primary-color);
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Load Session Button Styles */
#loadSessionButton {
    background-color: var(--primary-color);
}

#loadSessionButton:hover {
    background-color: var(--primary-hover-color);
}

/* Drop Zone Styles */
.drop-zone {
    border: 2px dashed var(--primary-color);
    border-radius: 8px;
    transition: all 0.3s ease;
}

.drop-zone.drag-over {
    background-color: rgba(46, 204, 113, 0.1);
    border-color: var(--secondary-color);
}

.tag-overlay-placeholder {
    color: var(--text-color);
    opacity: 0.7;
    font-style: italic;
    padding: 10px;
    text-align: center;
}

#frameCounter {
    font-weight: bold;
    font-size: 14px;
    background-color: rgba(0, 0, 0, 0.1);
    padding: 5px 10px;
    border-radius: 5px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0px 0px 17px #1e8147, 0px 0px 0px 1px #1daf40a1;
    margin-top: 7.5px;
}

/* Add this to the end of your main.css file */
.shortcut-overlay {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background-color: rgb(0 0 0 / 5%);
    color: white;
    padding: 15px;
    border-radius: 10px;
    font-size: 14px;
    z-index: 1000;
    max-width: 300px;
    box-shadow: 0 0 6px 3px rgb(0 0 0 / 31%);
    transition: opacity 0.3s ease;
}

.shortcut-overlay h3 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 16px;
    color: var(--secondary-color);
    text-shadow: 0px 0px 20px #ffffff2b;
}

.shortcut-overlay ul {
    list-style-type: none;
    padding: 0;
    margin: 0;
}

.shortcut-overlay li {
    margin-bottom: 5px;
}
#showShortcutOverlay{
    box-shadow: none;
}


.shortcut-overlay .shortcut-key,
.shortcut-overlay .shortcut-key_blank {
    display: inline-block;
    background-color: var(--primary-color);
    color: white;
    padding: 2px 5px;
    border-radius: 3px;
    margin-right: 5px;
    font-family: monospace;
    font-weight: bold;
}

/* Crop Overlay Styles */
#cropOverlay {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 5;
    
}

.crop-box {
    position: absolute;
    border: 2px solid var(--crop-handle-color);
    cursor: move;
    pointer-events: all;
    box-sizing: border-box;
}

.crop-handle {
    position: absolute;
    width: var(--crop-handle-size);
    height: var(--crop-handle-size);
    background: var(--crop-handle-color);
    border: 2px solid white;
    border-radius: 50%;
    pointer-events: all;
}

.crop-handle.nw { top: -5px; left: -5px; cursor: nw-resize; }
.crop-handle.n  { top: -5px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
.crop-handle.ne { top: -5px; right: -5px; cursor: ne-resize; }
.crop-handle.w  { top: 50%; left: -5px; transform: translateY(-50%); cursor: w-resize; }
.crop-handle.e  { top: 50%; right: -5px; transform: translateY(-50%); cursor: e-resize; }
.crop-handle.sw { bottom: -5px; left: -5px; cursor: sw-resize; }
.crop-handle.s  { bottom: -5px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
.crop-handle.se { bottom: -5px; right: -5px; cursor: se-resize; }

#cropButton {
    background-color: var(--third-color);
    margin-left: 10px;
}

#cropButton:hover {
    background-color: var(--third-hover-color);
}

#cropButton.active {
    background-color: var(--fourth-color);
}

.tag-reorder.left {
    right: calc(100% + 2px);
    margin-right: 0;
    margin-right: -15px;
}

.tag-reorder.right {
    left: calc(100% + 2px);
    margin-left: 0;
    margin-left: -15px;
}

/* Add new styles for crop dimensions display */
.crop-dimensions {
    position: absolute;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 8px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: all;
    z-index: 10;
    display: flex;
    flex-direction: column;
    gap: 4px;
    top: 10px;
    left: 10px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.crop-dimensions input {
    width: 60px;
    padding: 2px 4px;
    background: var(--input-bg);
    border: 1px solid var(--input-border);
    color: white;
    border-radius: 3px;
}

.crop-dimensions label {
    display: flex;
    align-items: center;
    gap: 8px;
}

.crop-dimensions button {
    background: var(--secondary-color);
    border: none;
    color: white;
    padding: 4px 8px;
    border-radius: 3px;
    cursor: pointer;
    margin-top: 4px;
}

.crop-dimensions button:hover {
    background: var(--secondary-hover-color);
}

#cropSettingsButton {
    background-color: var(--third-color);
    margin: 0px;
    margin-top: 3px;
}

#cropSettingsButton:hover {
    background-color: var(--third-hover-color);
}

/* Update crop dimensions styles */
.crop-dimensions {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--modal-bg);
    color: white;
    padding: 20px;
    border-radius: 8px;
    font-size: 14px;
    z-index: 1001;
    display: flex;
    flex-direction: column;
    gap: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    border: 1px solid var(--modal-border);
}

.crop-dimensions label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
}

.crop-dimensions input {
    width: 80px;
    padding: 4px 8px;
    background: var(--input-bg);
    border: 1px solid var(--input-border);
    color: white;
    border-radius: 4px;
}

.crop-dimensions button {
    background: var(--secondary-color);
    border: none;
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 8px;
    width: 100%;
}

.crop-dimensions button:hover {
    background: var(--secondary-hover-color);
}
    </style>
</head>
<body>
    <!-- Sidebar -->
    <div id="sidebar">
        <button id="sidebarToggle">☰</button>
        <h2>Actions</h2>
       
        <div class="sidebar-item">
            
            <button id="tagManagerButton">Tag Manager</button>
        </div>
        <div class="sidebar-item">
            <button id="extractButton" disabled>Export Frames</button>
        </div>
        <div class="sidebar-item">
            <button id="loadSessionButton">Load Session</button>
            <input type="file" id="loadSessionInput" accept=".zip" style="display: none;">
        </div>
        <div class="sidebar-item">
            <button id="sidebarUploadButton">Upload Video</button>
            <input type="file" id="sidebarVideoInput" accept="video/*,.mkv,.avi,.mov,.flv,.wmv" style="display: none;">
        </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent">
        <div class="header-output-container">
            <h2 style="font-size: 1.2em; margin: 0; display: inline-block;">VideoFrames: Tag & Extract</h2>
            <div id="output"></div>
        </div>
        <div id="bottomRightControls">
            <button id="settingsButton" aria-label="Settings">
                <svg viewBox="0 0 24 24">
                    <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                </svg>
            </button>
            <button id="helpButton" aria-label="Help">
                <svg viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/>
                </svg>
            </button>
        </div>

        <div id="shortcutOverlay" class="shortcut-overlay">
            <h3>Keyboard Shortcuts</h3>
            <ul>
                <li><span class="shortcut-key" data-shortcut="addFrame"></span>: Add/Remove Frame</li>
                <li><span class="shortcut-key" data-shortcut="prevFrame"></span>: Previous Frame</li>
                <li><span class="shortcut-key" data-shortcut="nextFrame"></span>: Next Frame</li>
                <li><span class="shortcut-key" data-shortcut="openTagManager"></span>: Open Tag Manager</li>
                <li><span class="shortcut-key_blank">1-9</span>: Assign/Remove Tags</li>
            </ul>
        </div>

        <!-- Help Modal -->
        <div id="helpModal" class="modal">
            <div class="help-modal-content">
                <h2>How to Use VideoFrames: Tag & Extract</h2>
                
                <h3>Getting Started</h3>
                <ol>
                    <li><strong>Upload a Video:</strong> Click <button class="help-button-video">Upload Video</button> button in the sidebar to select and upload your video.</li>
                    <li><strong>Navigate the Video:</strong> Use the timeline below the video player to navigate through your video. You can click anywhere on the timeline or drag the scrubber for precise navigation.</li>
                    <li><strong>Toggle Sidebar:</strong> Click <button class="help-button-sidebar">☰</button> button to collapse or expand the sidebar for a better view of the video.</li>
                    <li><strong>Replace Video:</strong> To replace the current video, click the <button class="help-button-video">Replace Video</button> button in the sidebar. This will allow you to select a new video file without losing your current tags and settings.</li>
                </ol>

                <h3>Frame Management</h3>
                <ul>
                    <li><strong>Add/Remove Frame:</strong> Press the <span class="shortcut-key" data-shortcut="addFrame"></span> key or click the <button class="help-button-frame">Add/Remove Frame</button> button to mark frames for extraction. The (text) left of button is keyboard shortcut.</li>
                    <li><strong>Navigate Frames:</strong> Use the <span class="shortcut-key" data-shortcut="prevFrame"></span> and <span class="shortcut-key" data-shortcut="nextFrame"></span> keys to move between marked frames. You'll see visual indicators on the timeline for each marked frame.</li>
                    <li><strong>Frame Information:</strong> The frame info display above the video shows the current time and frame details, including any assigned tags.</li>
                </ul>

                <h3>Tagging System</h3>
                <ul>
                    <li><strong>Manage Tags:</strong> Click<button class="help-button-tag">Tag Manager</button> button from the sidebar to create & delete tags.</li>
                    <li><strong>Assign Tags:</strong> Use the tag overlay below the video to assign or remove tags from the current frame. You can click on a tag or use number keys <span class="shortcut-key_blank">1-9</span> for the first 9 tags.</li>
                    <li><strong>View Tags:</strong> Assigned tags are displayed in the frame information and will be included in the extracted frame filenames.</li>
                </ul>

                <h3>Keyboard Shortcuts</h3>
                <ul>
                    <li><strong><span class="shortcut-key" data-shortcut="addFrame"></span>:</strong> Add/Remove current frame</li>
                    <li><strong><span class="shortcut-key" data-shortcut="prevFrame"></span>:</strong> Navigate to previous marked frame</li>
                    <li><strong><span class="shortcut-key" data-shortcut="nextFrame"></span>:</strong> Navigate to next marked frame</li>
                    <li><strong><span class="shortcut-key" data-shortcut="openTagManager"></span>:</strong> Open Tag Manager</li>
                    <li><strong><span class="shortcut-key_blank">1-9</span>:</strong> Quickly assign/remove tags (first 9 tags)</li>
                </ul>

                <h3>Settings</h3>
                <p>Click the <button class="help-button-gear"><svg viewBox="0 0 24 24" width="16" height="16"><path fill="currentColor" d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" /></svg></button> icon in the bottom right to access settings:</p>
                <ul>
                    <li><strong>Shortcuts:</strong> Customize keyboard shortcuts for various actions.</li>
                    <li><strong>Export Settings:</strong> Choose image format, quality, and file naming options for extracted frames.</li>
                    <li><strong>Display Settings:</strong> Toggle the visibility of the shortcut overlay.</li>
                </ul>

                <h3>Extraction</h3>
                <ol>
                    <li>Once you've selected and tagged frames, click the <button class="help-button-extract">Export Frames</button> button in the sidebar.</li>
                    <li>Choose between two export options:
                        <ul>
                            <li><strong>Export Frames Only:</strong> This will export only the selected frames as image files.</li>
                            <li><strong>Export Frames with Session Data:</strong> This will export the frames along with the session data, including the original video, tags, and settings. This option allows you to reload the session later.</li>
                        </ul>
                    </li>
                    <li>Confirm the extraction when prompted.</li>
                    <li>Wait for the extraction process to complete.</li>
                    <li>A ZIP file will be downloaded containing the extracted frames and, if selected, the session data.</li>
                </ol>
                <p>Each frame will be saved as an image file with its assigned tags in the filename.</p>

                <h3>Loading a Session</h3>
                <ol>
                    <li>Click the <button class="help-button-sidebar">Load Session</button> button in the sidebar.</li>
                    <li>Select a previously exported ZIP file containing session data.</li>
                    <li>The application will load the video, frames, tags, and settings from the session file.</li>
                </ol>

                <h3>Additional Tips</h3>
                <ul>
                    <li>Hover over timeline indicators to preview frames without adding them.</li>
                    <li>The extract button is disabled until you've selected at least one frame.</li>
                    <li>You can reorder tags in the Tag Manager by dragging and dropping.</li>
                    <li>Use the settings to customize the application to your workflow.</li>
                    <li>The shortcut overlay can be toggled on/off in the settings menu.</li>
                </ul>
            </div>
        </div>

        <!-- Video Container -->
        <div id="videoContainer">
            <!-- Add this new div for the placeholder -->
            <div id="videoPlaceholder" class="drop-zone">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="64" height="64">
                    <path d="M16 16.25C16 18.0449 14.5449 19.5 12.75 19.5H12.6865C12.89 18.8699 13 18.1978 13 17.5C13 13.9101 10.0899 11 6.5 11C4.75351 11 3.16789 11.6888 2 12.8096V7.75C2 5.95507 3.45507 4.5 5.25 4.5H12.75C14.5449 4.5 16 5.95507 16 7.75V16.25ZM21.762 5.89334C21.9156 6.07414 22 6.30368 22 6.54096V17.4588C22 18.0111 21.5523 18.4588 21 18.4588C20.7627 18.4588 20.5332 18.3744 20.3524 18.2208L17 15.3709V8.62794L20.3524 5.77899C20.7732 5.42132 21.4043 5.47252 21.762 5.89334ZM12 17.5C12 14.4624 9.53757 12 6.5 12C3.46243 12 1 14.4624 1 17.5C1 20.5376 3.46243 23 6.5 23C9.53757 23 12 20.5376 12 17.5ZM7.00065 18L7.00111 20.5035C7.00111 20.7797 6.77725 21.0035 6.50111 21.0035C6.22497 21.0035 6.00111 20.7797 6.00111 20.5035L6.00065 18H3.4956C3.21973 18 2.99609 17.7762 2.99609 17.5C2.99609 17.2239 3.21973 17 3.4956 17H6.00046L6 14.4993C6 14.2231 6.22386 13.9993 6.5 13.9993C6.77614 13.9993 7 14.2231 7 14.4993L7.00046 17H9.49659C9.77246 17 9.99609 17.2239 9.99609 17.5C9.99609 17.7762 9.77246 18 9.49659 18H7.00065Z"/>
                </svg>
                <p>Drag and drop a video file here<br>or click <button id="uploadVideoButton">Upload Video</button><input type="file" id="videoInput" accept="video/*,.mkv,.avi,.mov,.flv,.wmv" style="display: none;"> to begin.</p>
            </div>
            <div class="video-wrapper" style="position: relative;">
                <!-- Existing video player -->
                <video id="videoPlayer"></video>
                <!-- Crop Overlay -->
                <div id="cropOverlay"></div>
            </div>
            <div id="frameInfo"></div>
            <div id="timeline" style="display: none;">
                <div id="progressLine"></div>
                <div id="scrubber"></div>
            </div>
            <div id="bottomControls" style="display: none;">
                <button id="addFrameButton">Add/Remove Frame (F)</button>
                <div id="frameCounter" style="margin-left: 10px; color: var(--secondary-color);"></div>
                <button id="cropButton">Enable Crop</button>
                <button id="cropSettingsButton" style="display: none;">Crop Settings</button>
                <div class="controls-divider"></div>
                <div id="tagOverlay"></div>
            </div>
        </div>
    </div>

    <!-- Tag Manager Modal -->
    <div id="tagManagerModal" class="modal">
        <div class="modal-content">
            <div class="tag-manager">
                <h2 style="margin-bottom: 38px;">Tag Manager</h2>
                <input type="text" id="newTagInput" placeholder="Add new tag (press Enter)">
                <div id="tagList"></div>
            </div>
        </div>
    </div>

    <!-- Add Loading Indicator -->
    <div id="loadingIndicator" class="loading-overlay" style="display: none;">
        <div class="spinner"></div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="settings-modal-content">
            <h2>Settings</h2>
            
            <div class="settings-group">
                <h3>Shortcuts</h3>
                <div class="setting-item">
                    <label for="addFrameShortcut">Add/Remove Frame:</label>
                    <input type="text" id="addFrameShortcut" class="shortcut-input" data-shortcut="addFrame">
                </div>
                <div class="setting-item">
                    <label for="prevFrameShortcut">Previous Frame:</label>
                    <input type="text" id="prevFrameShortcut" class="shortcut-input" data-shortcut="prevFrame">
                </div>
                <div class="setting-item">
                    <label for="nextFrameShortcut">Next Frame:</label>
                    <input type="text" id="nextFrameShortcut" class="shortcut-input" data-shortcut="nextFrame">
                </div>
                <div class="setting-item">
                    <label for="openTagManagerShortcut">Open Tag Manager:</label>
                    <input type="text" id="openTagManagerShortcut" class="shortcut-input" data-shortcut="openTagManager">
                </div>
            </div>
            
            <div class="settings-group">
                <h3>Export Settings</h3>
                <div class="setting-item">
                    <label for="imageFormat">Image Format:</label>
                    <select id="imageFormat">
                        <option value="png">PNG (Lossless)</option>
                        <option value="jpeg">JPEG (Lossy)</option>
                        <option value="webp">WebP</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label for="imageQuality">JPEG/WebP Quality (1-100):</label>
                    <input type="number" id="imageQuality" min="1" max="100" value="90">
                </div>
                <div class="setting-item">
                    <label for="imageFilePrefix">Image File Prefix:</label>
                    <input type="text" id="imageFilePrefix" value="frame">
                </div>
            </div>

            <div class="settings-group">
                <h3>Display Settings</h3>
                <div class="setting-item">
                    <label for="showShortcutOverlay">Show Shortcut Overlay:</label>
                    <input type="checkbox" id="showShortcutOverlay">
                </div>
            </div>



        </div>
    </div>

    <!-- JavaScript Code -->
<script>
    (function() {
    'use strict';

    // ---------------------------
    // Element Selectors
    // ---------------------------
    const elements = {
        videoInput: document.getElementById('videoInput'),
        extractButton: document.getElementById('extractButton'),
        output: document.getElementById('output'),
        videoPlayer: document.getElementById('videoPlayer'),
        timeline: document.getElementById('timeline'),
        scrubber: document.getElementById('scrubber'),
        progressLine: document.getElementById('progressLine'),
        frameInfo: document.getElementById('frameInfo'),
        sidebar: document.getElementById('sidebar'),
        sidebarToggle: document.getElementById('sidebarToggle'),
        mainContent: document.getElementById('mainContent'),
        tagList: document.getElementById('tagList'),
        newTagInput: document.getElementById('newTagInput'),
        tagManagerButton: document.getElementById('tagManagerButton'),
        tagManagerModal: document.getElementById('tagManagerModal'),
        tagOverlay: document.getElementById('tagOverlay'),
        addFrameButton: document.getElementById('addFrameButton'),
        helpButton: document.getElementById('helpButton'),
        helpModal: document.getElementById('helpModal'),
        settingsButton: document.getElementById('settingsButton'),
        settingsModal: document.getElementById('settingsModal'),
        settingsInputs: document.querySelectorAll('#settingsModal input, #settingsModal select'),
        videoPlaceholder: document.getElementById('videoPlaceholder'),
        uploadVideoButton: document.getElementById('uploadVideoButton'),
        loadingIndicator: document.getElementById('loadingIndicator'),
        frameCounter: document.getElementById('frameCounter'),
        loadSessionButton: document.getElementById('loadSessionButton'),
        loadSessionInput: document.getElementById('loadSessionInput'),
        shortcutOverlay: document.getElementById('shortcutOverlay'),
        showShortcutOverlayCheckbox: document.getElementById('showShortcutOverlay'),
        sidebarUploadButton: document.getElementById('sidebarUploadButton'),
        sidebarVideoInput: document.getElementById('sidebarVideoInput'),
        cropButton: document.getElementById('cropButton'),
        cropOverlay: document.getElementById('cropOverlay'),
        cropSettingsButton: document.getElementById('cropSettingsButton'),
    };

    // ---------------------------
    // Application State Variables
    // ---------------------------
    let videoSrc = '';
    let zipInstance = null;
    let tags = [];
    let frameTags = {}; // { 'frame_1.png': ['tag1', 'tag2'], ... }
    let selectedFrames = []; // Array to store selected frame times
    let currentIndicatorIndex = -1;
    let isTagManagerOpen = false;
    let isSettingsModalOpen = false;
    let originalVideoName = '';
    let lastUsedExportName = ''; // Store the last used export name
    let lastCropDimensions = null; // Store the last crop dimensions

    let isScrubberDragging = false;
    let isCropMode = false;
    let cropBox = null;
    let cropDimensions = null;

    // Add these variables at the top with other state variables
    let cropSettingsVisible = false;

    // ---------------------------
    // Settings
    // ---------------------------
    const defaultSettings = {
        shortcuts: {
            addFrame: 'F',
            prevFrame: 'ArrowLeft',
            nextFrame: 'ArrowRight',
            openTagManager: 'T'
        },
        export: {
            imageFormat: 'jpeg',
            imageQuality: 100,
            imageFilePrefix: 'Frame',
            scaleFactor: 1 // Add this line
        },
        display: {
            showShortcutOverlay: true
        }
    };

    let settings = { ...defaultSettings };

    // ---------------------------
    // Initialization
    // ---------------------------
    loadSettings();
    updateSettingsUI();
    updateShortcutDisplay();
    updateQualityInputVisibility();
    updateExtractButtonState();
    frameInfo.style.display = 'none';

    // ---------------------------
    // Event Listeners
    // ---------------------------

    // Video Upload Handlers
    elements.uploadVideoButton.addEventListener('click', () => {
        elements.videoInput.click();
    });

    elements.videoInput.addEventListener('change', handleVideoInputChange);

    elements.videoPlaceholder.addEventListener('dragover', handleDragOver);
    elements.videoPlaceholder.addEventListener('dragleave', handleDragLeave);
    elements.videoPlaceholder.addEventListener('drop', handleDrop);

    // Window Resizing
    window.addEventListener('resize', resizeVideo);

    // Extraction
    elements.extractButton.addEventListener('click', confirmExtraction);

    // Video Player Events
    elements.videoPlayer.addEventListener('timeupdate', handleVideoTimeUpdate);
    elements.videoPlayer.addEventListener('emptied', handleVideoEmptied);
    elements.videoPlayer.addEventListener('play', preventVideoPlay);

    // Sidebar Toggle
    elements.sidebarToggle.addEventListener('click', toggleSidebar);

    // Tag Manager
    elements.newTagInput.addEventListener('keypress', handleNewTagInputKeyPress);
    elements.tagManagerButton.addEventListener('click', openTagManager);
    elements.addFrameButton.addEventListener('click', addFrame);

    // Timeline and Scrubber
    elements.timeline.addEventListener('mousedown', handleTimelineMouseDown);
    elements.timeline.addEventListener('click', handleTimelineClick);
    document.addEventListener('mousemove', handleDocumentMouseMove);
    document.addEventListener('mouseup', handleDocumentMouseUp);

    // Modal Close Handlers
    document.addEventListener('keydown', handleGlobalKeyDown);

    // Shortcut Inputs
    document.querySelectorAll('.shortcut-input').forEach(input => {
        input.addEventListener('keydown', handleShortcutInput);
    });

    // Help Modal
    elements.helpButton.addEventListener('click', () => {
        elements.helpModal.style.display = 'block';
    });

    let helpModalMouseDownTarget = null;
    elements.helpModal.addEventListener('mousedown', (event) => {
       helpModalMouseDownTarget = event.target;
    });
    elements.helpModal.addEventListener('mouseup', (event) => {
       if (helpModalMouseDownTarget === elements.helpModal && event.target === elements.helpModal) {
           elements.helpModal.style.display = 'none';
       }
    });

    // Settings Modal
    elements.settingsButton.addEventListener('click', () => {
        elements.settingsModal.style.display = 'block';
        isSettingsModalOpen = true;
    });

    let settingsModalMouseDownTarget = null;
    elements.settingsModal.addEventListener('mousedown', (event) => {
       settingsModalMouseDownTarget = event.target;
    });
    elements.settingsModal.addEventListener('mouseup', (event) => {
       if (settingsModalMouseDownTarget === elements.settingsModal && event.target === elements.settingsModal) {
           closeSettingsModal();
       }
    });

    // Settings Inputs
    document.querySelector('.settings-modal-content').addEventListener('input', handleSettingsInput);

    // Load Session
    elements.loadSessionButton.addEventListener('click', () => {
        elements.loadSessionInput.click();
    });

    elements.loadSessionInput.addEventListener('change', handleLoadSession);

    // Prevent text selection during scrubbing
    document.addEventListener('mousedown', (event) => {
        if (event.target === elements.timeline || event.target === elements.scrubber) {
            document.body.classList.add('no-select');
        }
    });

    document.addEventListener('mouseup', () => {
        document.body.classList.remove('no-select');
    });

    // Prevent default drag behavior
    document.addEventListener('dragstart', preventDefaultDrag);
    elements.timeline.addEventListener('mousedown', () => {
        document.addEventListener('mousemove', preventDefaultDrag);
    });
    document.addEventListener('mouseup', () => {
        document.removeEventListener('mousemove', preventDefaultDrag);
    });

    // Sidebar Upload Button
    elements.sidebarUploadButton.addEventListener('click', () => {
        elements.sidebarVideoInput.click();
    });

    elements.sidebarVideoInput.addEventListener('change', handleVideoInputChange);

    // Add this to the Event Listeners section
    document.addEventListener('keydown', (event) => {
        // Don't handle shortcuts if we're in an input field or modal
        if (event.target.tagName === 'INPUT' || isModalOpen()) {
            return;
        }

        if (event.key === 'Escape') {
            if (elements.tagManagerModal.style.display === 'block') {
                closeTagManager();
            }
            if (elements.helpModal.style.display === 'block') {
                elements.helpModal.style.display = 'none';
            }
        } else if (event.key === ' ' || event.key === 'Spacebar') {
            event.preventDefault(); // Prevent page scrolling
            if (elements.videoPlayer.src) {
                if (elements.videoPlayer.paused) {
                    elements.videoPlayer.play();
                } else {
                    elements.videoPlayer.pause();
                }
            }
        } else if (isTagManagerOpen || isSettingsModalOpen) return;

        const key = event.key.toLowerCase();
        const shortcuts = settings.shortcuts;

        // ... rest of your existing shortcut handling code ...
    });

    // ---------------------------
    // Function Definitions
    // ---------------------------

    // ---------------------------
    // Video Handling Functions
    // ---------------------------
    function handleVideoInputChange(event) {
        const file = event.target.files[0];
        if (file) {
            handleVideoFile(file);
            updateFrameCounter();
            
            // Reset both file inputs
            elements.videoInput.value = '';
            elements.sidebarVideoInput.value = '';
        }
    }

    function handleVideoFile(file) {
        originalVideoName = file.name;
        lastUsedExportName = ''; // Reset last used export name when new video is loaded
        resetVideoState();

        videoSrc = URL.createObjectURL(file);
        elements.videoPlayer.src = videoSrc;
        elements.videoPlayer.controls = false;
        elements.videoPlayer.muted = false;

        elements.videoPlayer.addEventListener('loadedmetadata', () => {
            if (elements.videoPlayer.videoWidth === 0 || elements.videoPlayer.videoHeight === 0) {
                displayError(`Error: The selected file format is not supported by your browser.`);
                URL.revokeObjectURL(videoSrc);
                updateFrameCounter();
                return;
            }

            displayOutput(`Video loaded: <span style="color: var(--secondary-color); text-shadow: 0px 0px 1px #000000;">${file.name}</span>`);
            showUIElements(true);

            resizeVideo();
            updateTagOverlay();
            updateExtractButtonState();

            resetScrubberAndProgress();
            hideVideoPlaceholder();
            stopUploadButtonAnimation();
            
            // Update sidebar upload button text
            elements.sidebarUploadButton.textContent = 'Replace Video';
        });

        elements.videoPlayer.addEventListener('error', () => {
            displayError(`Error: Unable to load the video. The format may not be supported.`);
            URL.revokeObjectURL(videoSrc);
        });
    }

    function resetVideoState() {
        selectedFrames = [];
        frameTags = {};
        currentIndicatorIndex = -1;

        clearScreenshotIndicators();
        clearTagOverlay();
        clearFrameInfo();
        
        // Reset frame counter
        updateFrameCounter();
    }

    function handleVideoTimeUpdate() {
        updateFrameInfo();
        updateTagOverlay();
        updateActiveIndicator();
        updateScrubberPosition();
        updateProgressLine();
    }

    function handleVideoEmptied() {
        clearFrameInfo();
        clearTagOverlay();
        resetScrubberAndProgress();
        hideTimelineAndControls();
        updateExtractButtonState();
    }

    function preventVideoPlay(event) {
        // Only prevent automatic playing, not user-initiated playing
        if (!event.isTrusted) {
            event.preventDefault();
            elements.videoPlayer.pause();
        }
    }

    // ---------------------------
    // Drag and Drop Handlers
    // ---------------------------
    function handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
        elements.videoPlaceholder.classList.add('drag-over');
    }

    function handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        elements.videoPlaceholder.classList.remove('drag-over');
    }

    function handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        elements.videoPlaceholder.classList.remove('drag-over');

        const file = e.dataTransfer.files[0];
        if (file && isValidVideoFile(file)) {
            handleVideoFile(file);
            updateFrameCounter();
        } else {
            alert('Please drop a valid video file.');
        }
    }

    function isValidVideoFile(file) {
        return file.type.startsWith('video/') || file.name.endsWith('.mkv');
    }

    // ---------------------------
    // UI Update Functions
    // ---------------------------
    function displayOutput(message) {
        elements.output.innerHTML = message;
        elements.output.style.display = 'block';
    }

    function displayError(message) {
        displayOutput(message);
    }

    function showUIElements(show) {
        elements.timeline.style.display = show ? 'block' : 'none';
        document.getElementById('bottomControls').style.display = show ? 'flex' : 'none';
        elements.frameInfo.style.display = show ? 'block' : 'none';
    }

    function resetScrubberAndProgress() {
        elements.scrubber.style.left = '0%';
        elements.progressLine.style.width = '0%';
    }

    function hideVideoPlaceholder() {
        elements.videoPlaceholder.style.display = 'none';
    }

    function hideTimelineAndControls() {
        elements.timeline.style.display = 'none';
        document.getElementById('bottomControls').style.display = 'none';
    }

    function clearScreenshotIndicators() {
        const indicators = elements.timeline.querySelectorAll('.screenshot-indicator');
        indicators.forEach(indicator => indicator.remove());
    }

    function clearTagOverlay() {
        elements.tagOverlay.innerHTML = '';
        elements.tagOverlay.style.display = 'none';
    }

    function clearFrameInfo() {
        elements.frameInfo.textContent = '';
        elements.frameInfo.style.display = 'none';
    }

    function resetUploadButtonAnimation() {
        elements.uploadVideoButton.classList.remove('video-loaded');
    }

    function stopUploadButtonAnimation() {
        elements.uploadVideoButton.classList.add('video-loaded');
    }

    function updateExtractButtonState() {
        elements.extractButton.disabled = selectedFrames.length === 0 || !elements.videoPlayer.src;
    }

    // Update the resizeVideo function
    function resizeVideo() {
        if (!elements.videoPlayer.videoWidth || !elements.videoPlayer.videoHeight) return;

        const containerWidth = elements.mainContent.offsetWidth;
        const aspectRatio = elements.videoPlayer.videoWidth / elements.videoPlayer.videoHeight;
        const maxHeight = window.innerHeight * 0.8;
        const maxWidth = Math.min(containerWidth, 1200); // Limit max width
        
        let newWidth = maxWidth;
        let newHeight = newWidth / aspectRatio;

        if (newHeight > maxHeight) {
            newHeight = maxHeight;
            newWidth = newHeight * aspectRatio;
        }

        // Set video dimensions
        elements.videoPlayer.style.width = `${newWidth}px`;
        elements.videoPlayer.style.height = `${newHeight}px`;

        // Ensure the video wrapper matches video dimensions exactly
        const videoWrapper = elements.videoPlayer.closest('.video-wrapper');
        if (videoWrapper) {
            videoWrapper.style.width = `${newWidth}px`;
            videoWrapper.style.height = `${newHeight}px`;
        }

        // Update crop overlay dimensions
        if (elements.cropOverlay && elements.cropOverlay.style.display !== 'none') {
            elements.cropOverlay.style.width = `${newWidth}px`;
            elements.cropOverlay.style.height = `${newHeight}px`;
            
            // Update crop box dimensions if it exists
            if (cropBox && cropDimensions) {
                const boxWidth = cropDimensions.width * newWidth;
                const boxHeight = cropDimensions.height * newHeight;
                const boxLeft = cropDimensions.x * newWidth;
                const boxTop = cropDimensions.y * newHeight;
                
                cropBox.style.width = `${boxWidth}px`;
                cropBox.style.height = `${boxHeight}px`;
                cropBox.style.left = `${boxLeft}px`;
                cropBox.style.top = `${boxTop}px`;
            }
        }

        if (elements.videoPlayer.readyState > 0) {
            elements.frameInfo.style.display = 'block';
            updateFrameInfo();
        }
    }

    // ---------------------------
    // Frame Extraction Functions
    // ---------------------------
    function confirmExtraction() {
        const frameCount = selectedFrames.length;

        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.display = 'block';

        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';

        // Use last used export name if available, otherwise use video filename
        const defaultExportName = lastUsedExportName || originalVideoName.replace(/\.[^/.]+$/, "");

        // NEW: Compute original dimensions based on crop if applied
        const videoWidth = elements.videoPlayer.videoWidth;
        const videoHeight = elements.videoPlayer.videoHeight;
        let origWidth, origHeight;
        if (cropDimensions) {
            origWidth = Math.floor(cropDimensions.width * videoWidth);
            origHeight = Math.floor(cropDimensions.height * videoHeight);
        } else {
            origWidth = videoWidth;
            origHeight = videoHeight;
        }

        modalContent.innerHTML = `
            <div class="export-modal-header">
                <h3>Export ${frameCount} Frame${frameCount > 1 ? 's' : ''}</h3>
            </div>
            
            <div class="export-section">
                <label for="exportName">Export Name</label>
                <input type="text" id="exportName" value="${defaultExportName}" placeholder="Enter export name...">
            </div>
            
            <div class="export-section">
                <label>Image Dimensions</label>
                <div class="dimensions-display">
                    <div class="dimensions-box">
                        <p class="dim-label">Original Size</p>
                        <p class="dim-value">${origWidth} × ${origHeight}</p>
                    </div>
                    <div class="dimensions-box">
                        <p class="dim-label-new">New Size</p>
                        <p class="dim-value" id="newDimensionsDisplay">${Math.floor(origWidth * settings.export.scaleFactor)} × ${Math.floor(origHeight * settings.export.scaleFactor)}</p>
                    </div>
                </div>
                <div class="scale-factor-container">
                    <label for="scaleFactor">Scale Factor (%):</label>
                    <input type="number" id="scaleFactor" min="10" max="100" step="1" value="${Math.floor(settings.export.scaleFactor * 100)}">
                    <span>(10 - 100%)</span>
                </div>
            </div>
            
            <div class="export-buttons">
                <button id="exportFramesOnly" class="export-button">Export Frames Only</button>
                <button id="exportFramesWithSession" class="export-button">Export with Session</button>
            </div>
        `;
        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        // Update new dimensions display when scale factor changes
        document.getElementById('scaleFactor').addEventListener('input', function() {
            let percentage = parseFloat(this.value);
            if (isNaN(percentage)) percentage = 100;
            percentage = Math.max(10, Math.min(100, percentage));
            const sf = percentage / 100;
            const newW = Math.floor(origWidth * sf);
            const newH = Math.floor(origHeight * sf);
            document.getElementById('newDimensionsDisplay').textContent = `${newW} × ${newH}`;
            settings.export.scaleFactor = sf; // Save the scale factor as a decimal
            saveSettings();
        });

        document.getElementById('exportFramesOnly').addEventListener('click', () => {
            const exportName = document.getElementById('exportName').value.trim() || defaultExportName;
            lastUsedExportName = exportName; // Save the export name
            let percentage = parseFloat(document.getElementById('scaleFactor').value);
            if (isNaN(percentage)) percentage = 100;
            const scaleFactorValue = percentage / 100;
            document.body.removeChild(modal);
            extractFrames(false, exportName, scaleFactorValue);
        });

        document.getElementById('exportFramesWithSession').addEventListener('click', () => {
            const exportName = document.getElementById('exportName').value.trim() || defaultExportName;
            lastUsedExportName = exportName; // Save the export name
            let percentage = parseFloat(document.getElementById('scaleFactor').value);
            if (isNaN(percentage)) percentage = 100;
            const scaleFactorValue = percentage / 100;
            document.body.removeChild(modal);
            extractFrames(true, exportName, scaleFactorValue);
        });

        // Handle modal close on overlay click
        let modalClickStartedOnOverlay = false;
        let modalContentClicked = false;
        
        // Check if click is inside modal content
        const isClickInsideContent = (event) => {
            return modalContent.contains(event.target) || event.target === modalContent;
        };
        
        modal.addEventListener('mousedown', (event) => {
            modalClickStartedOnOverlay = event.target === modal;
            modalContentClicked = isClickInsideContent(event);
        });
        
        modal.addEventListener('mouseup', (event) => {
            // Only close if both mousedown and mouseup were on the overlay
            // and we didn't interact with the content
            if (modalClickStartedOnOverlay && 
                event.target === modal && 
                !modalContentClicked) {
                const exportName = document.getElementById('exportName').value.trim();
                if (exportName) {
                    lastUsedExportName = exportName;
                }
                document.body.removeChild(modal);
            }
            modalClickStartedOnOverlay = false;
            modalContentClicked = false;
        });
        
        // Prevent accidental closes if mouse moves over content
        modalContent.addEventListener('mouseover', () => {
            modalContentClicked = true;
        });
    }

    // Modify extractFrames to accept scaleFactor
    async function extractFrames(includeSessionData = true, exportName, scaleFactor) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        zipInstance = new JSZip();
        
        // Create main folder with export name
        const mainFolder = zipInstance.folder(exportName);
        
        // Create images folder if including session data
        const imagesFolder = includeSessionData ? mainFolder.folder('images') : mainFolder;

        elements.extractButton.disabled = true;

        // Show loading overlay
        const loadingMessage = createLoadingMessage('Starting frame extraction...');
        elements.loadingIndicator.appendChild(loadingMessage);
        elements.loadingIndicator.style.display = 'flex';

        const totalFrames = selectedFrames.length;
        let extractedFrames = 0;

        try {
            for (let i = 0; i < selectedFrames.length; i++) {
                await extractSingleFrame(selectedFrames[i], canvas, ctx, imagesFolder, i, scaleFactor);
                extractedFrames++;
                loadingMessage.textContent = `Extracting frames: ${extractedFrames} / ${totalFrames}`;
            }

            loadingMessage.textContent = 'Frames extracted. Processing...';

            if (includeSessionData) {
                await addVideoAndSessionData(mainFolder, exportName);
                const readmeContent = createReadmeContent(exportName);
                mainFolder.file('README.txt', readmeContent);
            }

            const loadingInterval = animateLoadingMessage('Preparing ZIP file', loadingMessage);

            const zipBlob = await zipInstance.generateAsync({ type: 'blob' });
            clearInterval(loadingInterval);
            
            saveAs(zipBlob, `${exportName}.zip`);

            loadingMessage.textContent = 'Download ready.';
            elements.extractButton.disabled = false;
            displayOutput(`${extractedFrames} frames extracted and zipped${includeSessionData ? ' with session data' : ''}.`);
        } catch (error) {
            console.error('Error during extraction:', error);
            displayError(`Error during extraction: ${error.message}`);
            elements.extractButton.disabled = false;
        } finally {
            elements.loadingIndicator.style.display = 'none';
            elements.loadingIndicator.removeChild(loadingMessage);
        }
    }

    // Modify extractSingleFrame to apply scaleFactor when exporting frames
    async function extractSingleFrame(time, canvas, ctx, folder, index, scaleFactor) {
        return new Promise((resolve) => {
            elements.videoPlayer.currentTime = time;
            elements.videoPlayer.onseeked = () => {
                const videoWidth = elements.videoPlayer.videoWidth;
                const videoHeight = elements.videoPlayer.videoHeight;
                let origW, origH;
                if (cropDimensions) {
                    const cropX = Math.floor(cropDimensions.x * videoWidth);
                    const cropY = Math.floor(cropDimensions.y * videoHeight);
                    const cropW = Math.floor(cropDimensions.width * videoWidth);
                    const cropH = Math.floor(cropDimensions.height * videoHeight);
                    origW = cropW;
                    origH = cropH;
                    canvas.width = cropW;
                    canvas.height = cropH;
                    ctx.drawImage(elements.videoPlayer, 
                        cropX, cropY, cropW, cropH,
                        0, 0, cropW, cropH);
                } else {
                    origW = videoWidth;
                    origH = videoHeight;
                    canvas.width = videoWidth;
                    canvas.height = videoHeight;
                    ctx.drawImage(elements.videoPlayer, 0, 0, videoWidth, videoHeight);
                }

                const mimeType = `image/${settings.export.imageFormat}`;
                const quality = settings.export.imageFormat === 'png' ? undefined : settings.export.imageQuality / 100;
                
                if (scaleFactor && scaleFactor < 1) {
                    const newW = Math.floor(origW * scaleFactor);
                    const newH = Math.floor(origH * scaleFactor);
                    let scaledCanvas = document.createElement('canvas');
                    scaledCanvas.width = newW;
                    scaledCanvas.height = newH;
                    const sctx = scaledCanvas.getContext('2d');
                    sctx.drawImage(canvas, 0, 0, origW, origH, 0, 0, newW, newH);
                    scaledCanvas.toBlob(async (blob) => {
                        if (blob) {
                            const frameNumber = index + 1;
                            const baseFilename = `${settings.export.imageFilePrefix}_${frameNumber}.${settings.export.imageFormat}`;
                            const tagsForFrame = frameTags[baseFilename] || [];
                            const taggedFilename = tagsForFrame.length > 0
                                ? `[${tagsForFrame.join('][')}]${baseFilename}`
                                : baseFilename;
                            folder.file(taggedFilename, blob);
                        } else {
                            console.error(`Failed to extract frame at ${time}s`);
                        }
                        resolve();
                    }, mimeType, quality);
                } else {
                    canvas.toBlob(async (blob) => {
                        if (blob) {
                            const frameNumber = index + 1;
                            const baseFilename = `${settings.export.imageFilePrefix}_${frameNumber}.${settings.export.imageFormat}`;
                            const tagsForFrame = frameTags[baseFilename] || [];
                            const taggedFilename = tagsForFrame.length > 0
                                ? `[${tagsForFrame.join('][')}]${baseFilename}`
                                : baseFilename;
                            folder.file(taggedFilename, blob);
                        } else {
                            console.error(`Failed to extract frame at ${time}s`);
                        }
                        resolve();
                    }, mimeType, quality);
                }
            };
        });
    }

    async function addVideoAndSessionData(mainFolder, exportName) {
        try {
            const videoBlob = await fetch(videoSrc).then(res => res.blob());
            let videoExtension = getVideoExtension(videoBlob, originalVideoName);
            const videoFilename = `video.${videoExtension}`;
            mainFolder.file(videoFilename, videoBlob);

            const sessionData = {
                videoName: originalVideoName,
                videoType: videoBlob.type,
                videoLength: elements.videoPlayer.duration,
                selectedFrames: selectedFrames,
                frameTags: frameTags,
                settings: settings,
                tags: tags,
                exportName: exportName,
                // Added crop state
                cropEnabled: isCropMode,
                cropDimensions: cropDimensions
            };
            mainFolder.file('session.json', JSON.stringify(sessionData, null, 2));
        } catch (error) {
            throw new Error(`Failed to add video and session data: ${error.message}`);
        }
    }

    function createReadmeContent(exportName) {
        const sessionData = {
            videoName: originalVideoName,
            videoLength: elements.videoPlayer.duration,
            selectedFrames: selectedFrames,
            frameTags: frameTags,
            settings: settings,
            tags: tags,
            exportName: exportName
        };

        return `VideoFrames: Tag & Extract - Session Archive

This ZIP archive contains extracted video frames, session data, and the original video file.

Contents:
1. Extracted Frames: Image files of the selected video frames
2. session.json: Contains session data including frame timings, tags, and settings
3. video.{extension}: The original video file
4. README.txt: This file

How to use this archive:
1. To view extracted frames: Open the image files in any image viewer
2. To reload the session:
    a. Go to the VideoFrames: Tag & Extract web application
    b. Click the "Load Session" button
    c. Select this ZIP file

Session Information:
- Video Name: ${sessionData.videoName}
- Video Duration: ${formatDuration(sessionData.videoLength)}
- Number of Extracted Frames: ${sessionData.selectedFrames.length}
- Tags Used: ${sessionData.tags.join(', ')}

For more information on using VideoFrames: Tag & Extract, please refer to the help documentation in the application.

Created on: ${new Date().toLocaleString()}
`;
    }

    function createLoadingMessage(initialText) {
        const messageElem = document.createElement('div');
        messageElem.style.color = 'white';
        messageElem.style.marginLeft = '20px';
        messageElem.style.fontSize = '18px';
        messageElem.textContent = initialText;
        return messageElem;
    }

    function getVideoExtension(videoBlob, originalVideoName) {
        let extension = videoBlob.type.split('/')[1];
        if (extension === 'quicktime') {
            extension = 'mov';
        }
        if (extension === 'plain' || !extension) {
            const parts = originalVideoName.split('.');
            extension = parts.length > 1 ? parts.pop().toLowerCase() : 'mkv';
        }
        return extension;
    }

    function formatDuration(seconds) {
        const hrs = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // ---------------------------
    // Scrubber and Timeline Functions
    // ---------------------------
    function handleTimelineMouseDown(event) {
        isScrubberDragging = true;
        seekVideo(event);
    }

    function handleTimelineClick(event) {
        seekVideo(event);
    }

    function handleDocumentMouseMove(event) {
        if (isScrubberDragging) {
            seekVideo(event);
        }
    }

    function handleDocumentMouseUp() {
        if (isScrubberDragging) {
            isScrubberDragging = false;
            document.body.classList.remove('no-select');
        }
    }

    function seekVideo(event) {
        const rect = elements.timeline.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const percentage = Math.min(Math.max(x / elements.timeline.offsetWidth, 0), 1);
        let newTime = percentage * elements.videoPlayer.duration;

        // Reduce snap threshold from 1% to 0.25% of video duration
        const snapThreshold = 0.0025 * elements.videoPlayer.duration;
        const nearestFrame = findNearestFrame(newTime, snapThreshold);

        if (nearestFrame !== null) {
            newTime = nearestFrame;
        }

        elements.videoPlayer.currentTime = newTime;
        updateScrubberPosition();
        updateProgressLine();
        updateFrameInfo();
        updateTagOverlay();
        updateActiveIndicator();
    }

    function findNearestFrame(time, threshold) {
        let nearest = null;
        let minDistance = Infinity;

        selectedFrames.forEach(frameTime => {
            const distance = Math.abs(frameTime - time);
            if (distance < minDistance && distance < threshold) {
                minDistance = distance;
                nearest = frameTime;
            }
        });

        return nearest;
    }

    function updateScrubberPosition() {
        const percentage = (elements.videoPlayer.currentTime / elements.videoPlayer.duration) * 100;
        elements.scrubber.style.left = `calc(${percentage}% + 3px)`; // Adjust for scrubber width
    }

    function updateProgressLine() {
        const percentage = (elements.videoPlayer.currentTime / elements.videoPlayer.duration) * 100;
        elements.progressLine.style.width = `${Math.min(percentage + 0.25, 100)}%`;
    }

    // ---------------------------
    // Frame and Tag Management Functions
    // ---------------------------
    function addFrame() {
        const currentTime = elements.videoPlayer.currentTime;
        const existingIndex = selectedFrames.findIndex(time => Math.abs(time - currentTime) < 0.1);

        if (existingIndex === -1) {
            // Add new frame
            selectedFrames.push(currentTime);
            
            // Sort frames and get the new index of our just-added frame
            selectedFrames.sort((a, b) => a - b);
            const newIndex = selectedFrames.findIndex(time => time === currentTime);
            
            // If the new frame wasn't added at the end, we need to shift all frame tags
            if (newIndex < selectedFrames.length - 1) {
                // Create a new frameTags object
                const newFrameTags = {};
                
                // Copy tags for frames before the insertion point as is
                for (let i = 0; i < newIndex; i++) {
                    const frameName = `${settings.export.imageFilePrefix}_${i + 1}.${settings.export.imageFormat}`;
                    if (frameTags[frameName]) {
                        newFrameTags[frameName] = frameTags[frameName];
                    }
                }
                
                // Skip the new frame (it starts with no tags)
                
                // Shift all subsequent frame tags up by one
                for (let i = newIndex; i < selectedFrames.length - 1; i++) {
                    const oldFrameName = `${settings.export.imageFilePrefix}_${i + 1}.${settings.export.imageFormat}`;
                    const newFrameName = `${settings.export.imageFilePrefix}_${i + 2}.${settings.export.imageFormat}`;
                    if (frameTags[oldFrameName]) {
                        newFrameTags[newFrameName] = frameTags[oldFrameName];
                    }
                }
                
                // Replace the old frameTags with our new one
                frameTags = newFrameTags;
            }
        } else {
            // Remove frame
            selectedFrames.splice(existingIndex, 1);
            
            // Create a new frameTags object
            const newFrameTags = {};
            
            // Remove tags for the deleted frame and shift remaining tags down
            for (let i = 0; i < selectedFrames.length; i++) {
                const oldFrameName = `${settings.export.imageFilePrefix}_${i + 2}.${settings.export.imageFormat}`;
                const newFrameName = `${settings.export.imageFilePrefix}_${i + 1}.${settings.export.imageFormat}`;
                if (i < existingIndex) {
                    // Keep the same frame number for frames before the deleted one
                    const frameName = `${settings.export.imageFilePrefix}_${i + 1}.${settings.export.imageFormat}`;
                    if (frameTags[frameName]) {
                        newFrameTags[frameName] = frameTags[frameName];
                    }
                } else if (frameTags[oldFrameName]) {
                    // Shift frame numbers down for frames after the deleted one
                    newFrameTags[newFrameName] = frameTags[oldFrameName];
                }
            }
            
            // Replace the old frameTags with our new one
            frameTags = newFrameTags;
        }

        updateScreenshotIndicators();
        updateFrameInfo();
        updateFrameCounter();
        updateExtractButtonState();
    }

    function updateScreenshotIndicators() {
        clearScreenshotIndicators();

        selectedFrames.forEach((time, index) => {
            const indicator = document.createElement('div');
            indicator.className = 'screenshot-indicator';
            indicator.style.left = `${(time / elements.videoPlayer.duration) * 100}%`;
            indicator.title = `Frame at ${time.toFixed(2)} seconds`;
            indicator.dataset.time = time;
            indicator.dataset.index = index;

            indicator.addEventListener('click', (event) => {
                event.stopPropagation();
                elements.videoPlayer.currentTime = time;
                updateFrameInfo();
                updateTagOverlay();
                updateActiveIndicator();
                currentIndicatorIndex = index;
            });

            indicator.addEventListener('mouseenter', handleIndicatorMouseEnter);

            elements.timeline.appendChild(indicator);
        });

        if (currentIndicatorIndex >= selectedFrames.length) {
            currentIndicatorIndex = selectedFrames.length - 1;
        }
    }

    function handleIndicatorMouseEnter(event) {
        const time = parseFloat(event.target.dataset.time);
        const indicators = elements.timeline.querySelectorAll('.screenshot-indicator');
        
        // Remove active class from all indicators first
        indicators.forEach(ind => ind.classList.remove('active'));
        
        // Add active class only to the current indicator
        event.target.classList.add('active');
        
        elements.videoPlayer.currentTime = time;
        updateScrubberPosition();
        updateFrameInfo();
        updateTagOverlay();
    }

    function updateActiveIndicator() {
        const currentTime = elements.videoPlayer.currentTime;
        const indicators = elements.timeline.querySelectorAll('.screenshot-indicator');
        let closestIndicator = null;
        let minDistance = 0.1; // Threshold of 0.1 seconds
        
        indicators.forEach((indicator, index) => {
            const indicatorTime = parseFloat(indicator.dataset.time);
            const distance = Math.abs(currentTime - indicatorTime);
            
            if (distance < minDistance) {
                minDistance = distance;
                closestIndicator = indicator;
                currentIndicatorIndex = index;
            }
            
            // Remove active class from all indicators
            indicator.classList.remove('active');
        });
        
        // Add active class only to the closest indicator if within threshold
        if (closestIndicator) {
            closestIndicator.classList.add('active');
        }
    }

    function updateFrameInfo() {
        if (elements.videoPlayer.readyState === 0) {
            elements.frameInfo.style.display = 'none';
            return;
        }

        const currentTime = elements.videoPlayer.currentTime;
        const index = selectedFrames.findIndex(time => Math.abs(time - currentTime) < 0.1);
        const frameNumber = index + 1;
        let currentFrame = '';
        let taggedFilename = '';

        if (index !== -1) {
            currentFrame = `${settings.export.imageFilePrefix}_${frameNumber}.${settings.export.imageFormat}`;
            const tagsForFrame = frameTags[currentFrame] || [];
            taggedFilename = tagsForFrame.length > 0
                ? `[${tagsForFrame.join('][')}]${currentFrame}`
                : currentFrame;
        }

        const timeString = formatDuration(currentTime);
        elements.frameInfo.textContent = `Time: ${timeString} - ${taggedFilename}`;
        elements.frameInfo.style.display = 'block';
    }

    function updateTagOverlay() {
        elements.tagOverlay.innerHTML = '';

        if (elements.videoPlayer.readyState === 0) {
            elements.tagOverlay.style.display = 'none';
            return;
        }

        if (tags.length === 0) {
            const placeholder = document.createElement('span');
            placeholder.className = 'tag-overlay-placeholder';
            placeholder.textContent = 'No tags available. Click "Tag Manager" to add tags.';
            elements.tagOverlay.appendChild(placeholder);
            elements.tagOverlay.style.display = 'flex';
            return;
        }

        const currentFrame = getCurrentFrameFilename();
        const tagsForFrame = frameTags[currentFrame] || [];

        tags.forEach((tag, index) => {
            const tagElem = document.createElement('span');
            tagElem.className = 'tag-overlay-item';
            const shortcut = getShortcutDisplay(index);
            tagElem.textContent = shortcut ? `${tag} (${shortcut})` : tag;
            tagElem.dataset.tag = tag;

            if (tagsForFrame.includes(tag)) {
                tagElem.classList.add('selected');
            }

            tagElem.addEventListener('click', () => {
                toggleTagForCurrentFrame(tag);
                updateTagOverlay();
                updateFrameInfo();
            });

            elements.tagOverlay.appendChild(tagElem);
        });

        elements.tagOverlay.style.display = 'flex';
    }

    function toggleTagForCurrentFrame(tag) {
        const currentFrame = getCurrentFrameFilename();
        if (!currentFrame) return;

        if (!frameTags[currentFrame]) {
            frameTags[currentFrame] = [];
        }

        if (frameTags[currentFrame].includes(tag)) {
            frameTags[currentFrame] = frameTags[currentFrame].filter(t => t !== tag);
            if (frameTags[currentFrame].length === 0) {
                delete frameTags[currentFrame];
            }
        } else {
            frameTags[currentFrame].push(tag);
        }
    }

    function getCurrentFrameFilename() {
        const currentTime = elements.videoPlayer.currentTime;
        const index = selectedFrames.findIndex(time => Math.abs(time - currentTime) < 0.1);
        if (index === -1) return null;
        return `${settings.export.imageFilePrefix}_${index + 1}.${settings.export.imageFormat}`;
    }

    function updateFrameCounter() {
        elements.frameCounter.textContent = `Frames: ${selectedFrames.length}`;
    }

    // ---------------------------
    // Tag Management Functions
    // ---------------------------
    function openTagManager() {
        elements.tagManagerModal.style.display = 'block';
        isTagManagerOpen = true;
        
        // Add keydown event listener when opening
        document.addEventListener('keydown', handleTagManagerKeydown);
        
        setTimeout(() => {
            elements.newTagInput.focus();
            elements.newTagInput.value = '';
        }, 0);
    }

    function closeTagManager() {
        elements.tagManagerModal.style.display = 'none';
        isTagManagerOpen = false;
        
        // Remove keydown event listener when closing
        document.removeEventListener('keydown', handleTagManagerKeydown);
    }

    function handleNewTagInputKeyPress(event) {
        if (event.key === 'Enter') {
            addNewTag();
        }
    }

    function addNewTag() {
        const tag = elements.newTagInput.value.trim();
        if (tag && !tags.includes(tag)) {
            tags.push(tag);
            renderTags();
            elements.newTagInput.value = '';
            updateTagOverlay();
        }
    }

    function renderTags() {
        elements.tagList.innerHTML = '';
        tags.forEach((tag, index) => {
            const tagElem = document.createElement('span');
            tagElem.className = 'tag-item';
            tagElem.dataset.tagName = tag; // Add data attribute for tracking
            // Add shortcut number using getShortcutDisplay for all tags
            const shortcutText = getShortcutDisplay(index) ? ` (${getShortcutDisplay(index)})` : '';
            tagElem.innerHTML = `${tag}${shortcutText} <span class="delete-tag" title="Remove Tag">×</span>`;
            tagElem.dataset.tag = tag;

            // Add reorder buttons
            if (tags.length > 1) { // Only show reorder if there's more than one tag
                // Left reorder
                if (index > 0) {
                    const leftReorder = document.createElement('div');
                    leftReorder.className = 'tag-reorder left';
                    leftReorder.innerHTML = `
                        <button title="Move Left">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M15 18l-6-6 6-6"/>
                            </svg>
                        </button>
                    `;
                    leftReorder.querySelector('button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        const btn = e.currentTarget;
                        btn.style.transform = 'scale(0.9)';
                        setTimeout(() => btn.style.transform = '', 100);
                        moveTag(index, index - 1, tag); // Pass the tag name
                    });
                    tagElem.appendChild(leftReorder);
                }
                
                // Right reorder
                if (index < tags.length - 1) {
                    const rightReorder = document.createElement('div');
                    rightReorder.className = 'tag-reorder right';
                    rightReorder.innerHTML = `
                        <button title="Move Right">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </button>
                    `;
                    rightReorder.querySelector('button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        const btn = e.currentTarget;
                        btn.style.transform = 'scale(0.9)';
                        setTimeout(() => btn.style.transform = '', 100);
                        moveTag(index, index + 1, tag); // Pass the tag name
                    });
                    tagElem.appendChild(rightReorder);
                }
            }

            const deleteButton = tagElem.querySelector('.delete-tag');
            deleteButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const btn = e.currentTarget;
                btn.style.transform = 'scale(0.9)';
                setTimeout(() => btn.style.transform = '', 100);
                deleteTag(tag);
            });

            elements.tagList.appendChild(tagElem);
        });
    }

    function deleteTag(tagToDelete) {
        tags = tags.filter(tag => tag !== tagToDelete);

        for (const frame in frameTags) {
            frameTags[frame] = frameTags[frame].filter(tag => tag !== tagToDelete);
            if (frameTags[frame].length === 0) {
                delete frameTags[frame];
            }
        }

        renderTags();
        updateTagOverlay();
        updateFrameInfo();
    }

    // Add moveTag function
    function moveTag(fromIndex, toIndex, tagName) {
        // Swap tags
        const tag = tags[fromIndex];
        tags.splice(fromIndex, 1);
        tags.splice(toIndex, 0, tag);
        
        // Update UI
        renderTags();
        updateTagOverlay();
        
        // Find and animate the moved tag using the data attribute
        setTimeout(() => {
            const movedTagElement = elements.tagList.querySelector(`[data-tag-name="${tagName}"]`);
            if (movedTagElement) {
                movedTagElement.classList.add('tag-move');
                // Remove the animation class after it completes
                movedTagElement.addEventListener('animationend', () => {
                    movedTagElement.classList.remove('tag-move');
                }, { once: true });
            }
        }, 0);
        
        // Update any frames that have these tags
        for (const frame in frameTags) {
            if (frameTags[frame].length > 0) {
                updateFrameInfo();
                break;
            }
        }
    }

    // ---------------------------
    // Sidebar Functions
    // ---------------------------
    function toggleSidebar() {
        elements.sidebar.classList.toggle('collapsed');
        elements.mainContent.classList.toggle('expanded');
        setTimeout(resizeVideo, 0);
    }

    // ---------------------------
    // Keyboard Shortcut Functions
    // ---------------------------
    document.addEventListener('keydown', (event) => {
        // Don't handle shortcuts if we're in an input field or modal
        if (event.target.tagName === 'INPUT' || isModalOpen()) {
            return;
        }

        if (event.key === 'Escape') {
            if (elements.tagManagerModal.style.display === 'block') {
                closeTagManager();
            }
            if (elements.helpModal.style.display === 'block') {
                elements.helpModal.style.display = 'none';
            }
        } else if (event.key === ' ' || event.key === 'Spacebar') {
            event.preventDefault(); // Prevent page scrolling
            if (elements.videoPlayer.src) {
                if (elements.videoPlayer.paused) {
                    elements.videoPlayer.play();
                } else {
                    elements.videoPlayer.pause();
                }
            }
        } else if (isTagManagerOpen || isSettingsModalOpen) return;

        const key = event.key.toLowerCase();
        const shortcuts = settings.shortcuts;

        if (key === shortcuts.openTagManager.toLowerCase()) {
            event.preventDefault();
            openTagManager();
        } else if (key === shortcuts.addFrame.toLowerCase()) {
            event.preventDefault();
            addFrame();
            animateAddFrameButton();
        } else if (event.key === shortcuts.prevFrame) {
            event.preventDefault();
            if (event.shiftKey) {
                const secondsJump = .25; // jump 1 second instead of a fraction of a frame
                elements.videoPlayer.currentTime = clampTime(elements.videoPlayer.currentTime - secondsJump);
                updateAllAfterTimeChange();
            } else {
                navigateIndicators(-1);
            }
        } else if (event.key === shortcuts.nextFrame) {
            event.preventDefault();
            if (event.shiftKey) {
                const secondsJump = .25; // jump 1 second instead of a fraction of a frame
                elements.videoPlayer.currentTime = clampTime(elements.videoPlayer.currentTime + secondsJump);
                updateAllAfterTimeChange();
            } else {
                navigateIndicators(1);
            }
        } else {
            const tagIndex = getTagIndexFromKey(event.key);
            if (tagIndex !== null && tagIndex < tags.length) {
                toggleTagForCurrentFrame(tags[tagIndex]);
                updateTagOverlay();
                updateFrameInfo();
            }
        }
    });

    function navigateIndicators(direction) {
        if (!elements.videoPlayer.src || elements.videoPlayer.readyState === 0) {
            console.log("Video not loaded yet.");
            return;
        }

        if (selectedFrames.length === 0) {
            const step = direction * 2;
            elements.videoPlayer.currentTime = clampTime(elements.videoPlayer.currentTime + step);
            updateAllAfterTimeChange();
            return;
        }

        const currentTime = elements.videoPlayer.currentTime;
        let nearestFrameIndex = -1;
        let nearestFrameDistance = Infinity;

        selectedFrames.forEach((frameTime, index) => {
            const distance = frameTime - currentTime;
            if (direction === -1 && distance < 0 && Math.abs(distance) < nearestFrameDistance) {
                nearestFrameIndex = index;
                nearestFrameDistance = Math.abs(distance);
            } else if (direction === 1 && distance > 0 && distance < nearestFrameDistance) {
                nearestFrameIndex = index;
                nearestFrameDistance = distance;
            }
        });

        if (nearestFrameIndex === -1) {
            nearestFrameIndex = direction === -1 ? selectedFrames.length - 1 : 0;
        }

        if (nearestFrameIndex !== -1) {
            elements.videoPlayer.currentTime = selectedFrames[nearestFrameIndex];
            currentIndicatorIndex = nearestFrameIndex;
            updateAllAfterTimeChange();
        }
    }

    function clampTime(time) {
        return Math.max(0, Math.min(elements.videoPlayer.duration, time));
    }

    function updateAllAfterTimeChange() {
        updateFrameInfo();
        updateTagOverlay();
        updateActiveIndicator();
        updateScrubberPosition();
    }

    // ---------------------------
    // UI Animations
    // ---------------------------
    function animateAddFrameButton() {
        elements.addFrameButton.classList.add('button-pulse');
        setTimeout(() => {
            elements.addFrameButton.classList.remove('button-pulse');
        }, 300);
    }

    function animateLoadingMessage(message, element) {
        let dots = 0;
        const maxDots = 3;
        const interval = setInterval(() => {
            dots = (dots + 1) % (maxDots + 1);
            element.textContent = `${message}${'.'.repeat(dots)}`;
        }, 500);
        return interval;
    }

    // ---------------------------
    // Modal Management Functions
    // ---------------------------
    function handleWindowClick(event) {
        if (event.target === elements.tagManagerModal) {
            closeTagManager();
        }
        if (event.target === elements.helpModal) {
            elements.helpModal.style.display = 'none';
        }
    }

    function handleGlobalKeyDown(event) {
        // Don't handle shortcuts if we're in an input field or modal
        if (event.target.tagName === 'INPUT' || isModalOpen()) {
            return;
        }

        if (event.key === 'Escape') {
            if (elements.tagManagerModal.style.display === 'block') {
                closeTagManager();
            }
            if (elements.helpModal.style.display === 'block') {
                elements.helpModal.style.display = 'none';
            }
        } else if (event.key === ' ' || event.key === 'Spacebar') {
            event.preventDefault(); // Prevent page scrolling
            if (elements.videoPlayer.src) {
                if (elements.videoPlayer.paused) {
                    elements.videoPlayer.play();
                } else {
                    elements.videoPlayer.pause();
                }
            }
        }
    }

    function closeSettingsModal() {
        elements.settingsModal.style.display = 'none';
        isSettingsModalOpen = false;
    }

    // ---------------------------
    // Shortcut Handling Functions
    // ---------------------------
    function handleShortcutInput(event) {
        event.preventDefault();
        const key = event.key;
        let shortcut = '';

        if (event.ctrlKey) shortcut += 'Ctrl+';
        if (event.altKey) shortcut += 'Alt+';
        if (event.shiftKey) shortcut += 'Shift+';

        if (key.length === 1 && key.match(/[a-z]/i)) {
            shortcut += key.toUpperCase();
        } else {
            shortcut += key;
        }

        event.target.value = shortcut;

        const shortcutName = event.target.dataset.shortcut;
        settings.shortcuts[shortcutName] = shortcut;

        saveSettings();
        updateSettingsUI();
        updateShortcutDisplay();
    }

    function isShortcutInput(element) {
        return element.classList.contains('shortcut-input');
    }

    function updateShortcutDisplay() {
        const shortcutElements = document.querySelectorAll('.shortcut-key');
        shortcutElements.forEach(element => {
            const shortcutName = element.dataset.shortcut;
            element.textContent = settings.shortcuts[shortcutName];
        });

        elements.addFrameButton.textContent = `Add/Remove Frame (${settings.shortcuts.addFrame})`;
    }

    // ---------------------------
    // Settings Management Functions
    // ---------------------------
    function handleSettingsInput(event) {
        const input = event.target;
        if (input.id === 'imageQuality') {
            validateImageQuality();
        } else if (input.id in settings.export) {
            settings.export[input.id] = input.value;
        } else if (input.id.endsWith('Shortcut')) {
            const shortcutName = input.id.replace('Shortcut', '');
            settings.shortcuts[shortcutName] = input.value;
        } else if (input.id === 'showShortcutOverlay') {
            settings.display.showShortcutOverlay = input.checked;
            updateShortcutOverlayVisibility();
        }
        saveSettings();
        updateFrameInfo();
        updateSettingsUI();
    }

    function validateImageQuality() {
        const imageQualityInput = document.getElementById('imageQuality');
        let value = parseInt(imageQualityInput.value, 10);
        if (isNaN(value) || value < 1) {
            value = 1;
        } else if (value > 100) {
            value = 100;
        }
        imageQualityInput.value = value;
        settings.export.imageQuality = value;
        saveSettings();
    }

    function updateSettingsUI() {
        document.getElementById('addFrameShortcut').value = settings.shortcuts.addFrame;
        document.getElementById('prevFrameShortcut').value = settings.shortcuts.prevFrame;
        document.getElementById('nextFrameShortcut').value = settings.shortcuts.nextFrame;
        document.getElementById('openTagManagerShortcut').value = settings.shortcuts.openTagManager;
        document.getElementById('imageFormat').value = settings.export.imageFormat;
        document.getElementById('imageQuality').value = settings.export.imageQuality;
        document.getElementById('imageFilePrefix').value = settings.export.imageFilePrefix;
        document.getElementById('showShortcutOverlay').checked = settings.display.showShortcutOverlay;

        updateShortcutDisplay();
        updateQualityInputVisibility();
        updateShortcutOverlayVisibility();
    }

    function updateQualityInputVisibility() {
        const imageQualityInput = document.getElementById('imageQuality');
        const imageQualityLabel = imageQualityInput.previousElementSibling;
        const isVisible = settings.export.imageFormat !== 'png';
        imageQualityInput.style.display = isVisible ? 'block' : 'none';
        imageQualityLabel.style.display = isVisible ? 'block' : 'none';
    }

    function updateShortcutOverlayVisibility() {
        elements.shortcutOverlay.style.display = settings.display.showShortcutOverlay ? 'block' : 'none';
    }

    // ---------------------------
    // Settings Persistence Functions
    // ---------------------------
    function loadSettings() {
        const savedSettings = localStorage.getItem('videoFramesSettings');
        if (savedSettings) {
            const parsedSettings = JSON.parse(savedSettings);
            settings = {
                ...settings,
                ...parsedSettings,
                shortcuts: {
                    ...settings.shortcuts,
                    ...parsedSettings.shortcuts
                },
                export: {
                    ...settings.export,
                    ...parsedSettings.export
                },
                display: {
                    ...settings.display,
                    ...parsedSettings.display
                }
            };
        }
        initializeShortcutOverlay();
    }

    function saveSettings() {
        localStorage.setItem('videoFramesSettings', JSON.stringify(settings));
    }

    function initializeShortcutOverlay() {
        updateShortcutOverlayVisibility();
        updateShortcutDisplay();
    }

    // ---------------------------
    // Load Session Functions
    // ---------------------------
    async function handleLoadSession(event) {
        const file = event.target.files[0];
        if (file) {
            showLoadingIndicator('Loading session...');
            try {
                const zip = await JSZip.loadAsync(file);
                const sessionFile = findSessionFile(zip);
                if (!sessionFile) {
                    throw new Error('Invalid session file. ZIP must contain a session.json file.');
                }

                const sessionData = await sessionFile.async('string').then(JSON.parse);
                await loadSessionData(zip, sessionData);

                displayOutput(`Session "${sessionData.zipFileName}.zip" loaded successfully.`);
                stopUploadButtonAnimation();
            } catch (error) {
                console.error('Error loading session:', error);
                displayError(`Error loading session: ${error.message}`);
            } finally {
                hideLoadingIndicator();
            }
        }
    }

    function findSessionFile(zip) {
        for (const filename in zip.files) {
            if (filename.endsWith('session.json')) {
                return zip.files[filename];
            }
        }
        return null;
    }

    async function loadSessionData(zip, sessionData) {
        originalVideoName = sessionData.videoName;
        settings = sessionData.settings || settings;
        tags = sessionData.tags || [];
        selectedFrames = sessionData.selectedFrames || [];
        frameTags = sessionData.frameTags || {};

        // Restore crop state if available
        if (sessionData.cropEnabled) {
            isCropMode = true;
            elements.cropButton.classList.add('active');
            elements.cropButton.textContent = 'Disable Crop';
            elements.cropSettingsButton.style.display = 'inline-block';
            if (sessionData.cropDimensions) {
                cropDimensions = sessionData.cropDimensions;
                lastCropDimensions = sessionData.cropDimensions; // Store in lastCropDimensions as well
            }
            initializeCropOverlay();
        } else {
            isCropMode = false;
            elements.cropButton.classList.remove('active');
            elements.cropButton.textContent = 'Enable Crop';
            elements.cropSettingsButton.style.display = 'none';
            cropDimensions = null;
            lastCropDimensions = null; // Clear lastCropDimensions if crop was disabled
            removeCropOverlay();
        }

        loadSettings();
        renderTags();
        updateScreenshotIndicators();
        updateTagOverlay();
        updateFrameCounter();
        updateFrameInfo();
        updateExtractButtonState();

        const videoFile = await findVideoFile(zip, sessionData);
        if (!videoFile) {
            throw new Error('Invalid session file. ZIP must contain a video file.');
        }

        const videoBlob = await videoFile.async('blob');
        const videoExtension = getVideoExtension(videoBlob, videoFile.name);
        videoSrc = URL.createObjectURL(new Blob([videoBlob], { type: `video/${videoExtension}` }));
        elements.videoPlayer.src = videoSrc;

        await new Promise(resolve => {
            elements.videoPlayer.onloadedmetadata = resolve;
        });

        if (elements.videoPlayer.videoWidth === 0 || elements.videoPlayer.videoHeight === 0) {
            throw new Error('Unsupported video format in session.');
        }

        showUIElements(true);
        resizeVideo();
        resetScrubberAndProgress();
        hideVideoPlaceholder();

        updateScreenshotIndicators();
        updateTagOverlay();
        updateFrameCounter();
        updateFrameInfo();
        updateExtractButtonState();
    }
    async function findVideoFile(zip, sessionData) {
        console.log('Finding video file in zip...');
        const sessionFolder = getSessionFolder(zip, 'session.json');
        console.log(`Session folder: ${sessionFolder}`);

        // Look for any video file in the session folder
        for (const filename in zip.files) {
            if (filename.startsWith(sessionFolder) && isVideoFile(filename)) {
                console.log(`Video file found: ${filename}`);
                return zip.files[filename];
            }
        }

        console.log('Video file not found');
        return null;
    }

    function isVideoFile(filename) {
    const videoExtensions = ['.mp4', '.webm', '.ogg', '.mov', '.avi', '.wmv', '.flv', '.mkv'];
    return videoExtensions.some(ext => filename.toLowerCase().endsWith(ext));
}

    function getSessionFolder(zip, sessionFilename) {
        console.log(`Searching for session folder containing ${sessionFilename}...`);
        for (const filename in zip.files) {
            console.log(`Checking file: ${filename}`);
            if (filename.endsWith(sessionFilename)) {
                const folder = filename.substring(0, filename.lastIndexOf('/') + 1);
                console.log(`Session folder found: ${folder}`);
                return folder;
            }
        }
        console.log('Session folder not found');
        return '';
    }

    // ---------------------------
    // Helper Functions
    // ---------------------------
    function preventDefaultDrag(e) {
        e.preventDefault();
    }

    function isModalOpen() {
        return elements.tagManagerModal.style.display === 'block' || elements.helpModal.style.display === 'block' || elements.settingsModal.style.display === 'block';
    }

    function showLoadingIndicator(message) {
        const loadingMessage = createLoadingMessage(message);
        elements.loadingIndicator.appendChild(loadingMessage);
        elements.loadingIndicator.style.display = 'flex';
    }

    function hideLoadingIndicator() {
        elements.loadingIndicator.style.display = 'none';
        elements.loadingIndicator.innerHTML = '';
    }

    // Add this to the Tag Management Functions section
    function handleTagManagerKeydown(event) {
        if (event.key === 'Escape') {
            closeTagManager();
        }
    }

    // Crop Overlay Functions
    function showCropOverlay(event) {
        const rect = elements.videoPlayer.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const width = rect.width;
        const height = rect.height;

        const cropBox = document.createElement('div');
        cropBox.className = 'crop-box';
        cropBox.style.position = 'absolute';
        cropBox.style.left = `${x}px`;
        cropBox.style.top = `${y}px`;
        cropBox.style.width = `${width}px`;
        cropBox.style.height = `${height}px`;
        cropBox.style.border = '2px dashed var(--crop-handle-color)';
        cropBox.style.boxShadow = '0 0 0 9999px rgba(0, 0, 0, 0.5)';
        cropBox.style.cursor = 'move';

        const nw = document.createElement('div');
        nw.className = 'crop-handle nw';
        nw.style.position = 'absolute';
        nw.style.left = '-5px';
        nw.style.top = '-5px';
        nw.style.width = '10px';
        nw.style.height = '10px';
        nw.style.border = '2px solid white';
        nw.style.borderRadius = '50%';
        nw.style.background = 'var(--crop-handle-color)';
        nw.addEventListener('mousedown', handleCropResize);

        const ne = document.createElement('div');
        ne.className = 'crop-handle ne';
        ne.style.position = 'absolute';
        ne.style.right = '-5px';
        ne.style.top = '-5px';
        ne.style.width = '10px';
        ne.style.height = '10px';
        ne.style.border = '2px solid white';
        ne.style.borderRadius = '50%';
        ne.style.background = 'var(--crop-handle-color)';
        ne.addEventListener('mousedown', handleCropResize);

        const sw = document.createElement('div');
        sw.className = 'crop-handle sw';
        sw.style.position = 'absolute';
        sw.style.left = '-5px';
        sw.style.bottom = '-5px';
        sw.style.width = '10px';
        sw.style.height = '10px';
        sw.style.border = '2px solid white';
        sw.style.borderRadius = '50%';
        sw.style.background = 'var(--crop-handle-color)';
        sw.addEventListener('mousedown', handleCropResize);

        const se = document.createElement('div');
        se.className = 'crop-handle se';
        se.style.position = 'absolute';
        se.style.right = '-5px';
        se.style.bottom = '-5px';
        se.style.width = '10px';
        se.style.height = '10px';
        se.style.border = '2px solid white';
        se.style.borderRadius = '50%';
        se.style.background = 'var(--crop-handle-color)';
        se.addEventListener('mousedown', handleCropResize);

        cropBox.appendChild(nw);
        cropBox.appendChild(ne);
        cropBox.appendChild(sw);
        cropBox.appendChild(se);

        document.body.appendChild(cropBox);

        document.addEventListener('mousemove', handleCropMove);
        document.addEventListener('mouseup', handleCropRelease);
    }

    function handleCropResize(event) {
        event.preventDefault();
        document.body.classList.add('crop-resizing');
        document.addEventListener('mousemove', handleCropResizeMove, true);
        document.addEventListener('mouseup', handleCropRelease, true);
    }

    function handleCropResizeMove(event) {
        event.preventDefault();
        const rect = elements.videoPlayer.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const width = rect.width;
        const height = rect.height;

        const cropBox = document.querySelector('.crop-box');
        cropBox.style.left = `${x}px`;
        cropBox.style.top = `${y}px`;
        cropBox.style.width = `${width}px`;
        cropBox.style.height = `${height}px`;
    }

    function handleCropRelease() {
        document.body.classList.remove('crop-resizing');
        document.removeEventListener('mousemove', handleCropResizeMove, true);
        document.removeEventListener('mouseup', handleCropRelease, true);
    }

    function handleCropMove(event) {
        event.preventDefault();
        const rect = elements.videoPlayer.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const width = rect.width;
        const height = rect.height;

        const cropBox = document.querySelector('.crop-box');
        cropBox.style.left = `${x}px`;
        cropBox.style.top = `${y}px`;
        cropBox.style.width = `${width}px`;
        cropBox.style.height = `${height}px`;
    }

    function cropVideo() {
        const cropBox = document.querySelector('.crop-box');
        const rect = cropBox.getBoundingClientRect();
        const x = rect.left;
        const y = rect.top;
        const width = rect.width;
        const height = rect.height;

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(elements.videoPlayer, x, y, width, height, 0, 0, width, height);

        const croppedBlob = canvas.toBlob(function(blob) {
            elements.videoPlayer.src = URL.createObjectURL(blob);
            elements.videoPlayer.controls = true;
            elements.videoPlayer.muted = false;
            document.body.removeChild(document.querySelector('#cropOverlay'));
        }, 'image/jpeg', 0.9);
    }

    // Add crop state
    let isDragging = false;
    let isResizing = false;
    let dragStart = { x: 0, y: 0 };
    let resizeHandle = null;
    let originalBox = { left: 0, top: 0, width: 0, height: 0 };

    // Add crop button event listener
    elements.cropButton.addEventListener('click', toggleCropMode);

    function toggleCropMode() {
        isCropMode = !isCropMode;
        elements.cropButton.classList.toggle('active');
        elements.cropButton.textContent = isCropMode ? 'Disable Crop' : 'Enable Crop';
        elements.cropSettingsButton.style.display = isCropMode ? 'inline-block' : 'none';
        
        if (isCropMode) {
            initializeCropOverlay();
        } else {
            removeCropOverlay();
            if (cropSettingsVisible) {
                document.querySelector('.crop-dimensions')?.remove();
                cropSettingsVisible = false;
            }
        }
    }

    // Updated initializeCropOverlay function
    function initializeCropOverlay() {
        const videoRect = elements.videoPlayer.getBoundingClientRect();
        elements.cropOverlay.style.display = 'block';
        elements.cropOverlay.style.width = `${videoRect.width}px`;
        elements.cropOverlay.style.height = `${videoRect.height}px`;

        // Create initial crop box
        cropBox = document.createElement('div');
        cropBox.className = 'crop-box';

        // Set initial size based on stored cropDimensions or default to full video size
        let initialDimensions;
        if (lastCropDimensions) {
            initialDimensions = {
                width: lastCropDimensions.width * videoRect.width,
                height: lastCropDimensions.height * videoRect.height,
                left: lastCropDimensions.x * videoRect.width,
                top: lastCropDimensions.y * videoRect.height
            };
        } else {
            initialDimensions = {
                width: videoRect.width,
                height: videoRect.height,
                left: 0,
                top: 0
            };
        }

        cropBox.style.width = `${initialDimensions.width}px`;
        cropBox.style.height = `${initialDimensions.height}px`;
        cropBox.style.left = `${initialDimensions.left}px`;
        cropBox.style.top = `${initialDimensions.top}px`;

        const handles = ['nw', 'n', 'ne', 'w', 'e', 'sw', 's', 'se'];
        handles.forEach(pos => {
            const handle = document.createElement('div');
            handle.className = `crop-handle ${pos}`;
            cropBox.appendChild(handle);
        });

        elements.cropOverlay.appendChild(cropBox);

        // Add event listeners
        cropBox.addEventListener('mousedown', startDragging);
        document.querySelectorAll('.crop-handle').forEach(handle => {
            handle.addEventListener('mousedown', startResizing);
        });
    }

    // Add new function to show crop settings
    function showCropSettings() {
        if (cropSettingsVisible) return;
        
        const dimensionsDisplay = document.createElement('div');
        dimensionsDisplay.className = 'crop-dimensions';
        dimensionsDisplay.innerHTML = `
            <label>Width: <input type="number" id="cropWidth" min="1" step="1"></label>
            <label>Height: <input type="number" id="cropHeight" min="1" step="1"></label>
            <label>X: <input type="number" id="cropX" step="1"></label>
            <label>Y: <input type="number" id="cropY" step="1"></label>
            <button id="applyCropDimensions">Apply</button>
        `;

        document.body.appendChild(dimensionsDisplay);
        cropSettingsVisible = true;

        // Add event listeners
        document.getElementById('applyCropDimensions').addEventListener('click', () => {
            applyManualDimensions();
            dimensionsDisplay.remove();
            cropSettingsVisible = false;
        });

        // Update the display with current values
        updateDimensionsDisplay();
    }

    // Add event listener for the crop settings button
    // Add this in your initialization code or where other event listeners are set up
    elements.cropSettingsButton.addEventListener('click', showCropSettings);

    // Update the updateDimensionsDisplay function
    function updateDimensionsDisplay() {
        if (!cropBox || !cropSettingsVisible) return;
        
        const cropWidthInput = document.getElementById('cropWidth');
        if (!cropWidthInput) return; // Exit if the dimensions overlay elements don't exist
        
        const videoRect = elements.videoPlayer.getBoundingClientRect();
        const boxRect = cropBox.getBoundingClientRect();
        
        // Calculate actual dimensions based on video resolution
        const actualVideoWidth = elements.videoPlayer.videoWidth;
        const actualVideoHeight = elements.videoPlayer.videoHeight;
        const scaleX = actualVideoWidth / videoRect.width;
        const scaleY = actualVideoHeight / videoRect.height;
        
        // Convert displayed dimensions to actual video resolution dimensions
        const actualWidth = Math.round(boxRect.width * scaleX);
        const actualHeight = Math.round(boxRect.height * scaleY);
        const actualX = Math.round((boxRect.left - videoRect.left) * scaleX);
        const actualY = Math.round((boxRect.top - videoRect.top) * scaleY);
        
        cropWidthInput.value = actualWidth;
        document.getElementById('cropHeight').value = actualHeight;
        document.getElementById('cropX').value = actualX;
        document.getElementById('cropY').value = actualY;
    }

    // Add new function to apply manual dimensions
    function applyManualDimensions() {
        const videoRect = elements.videoPlayer.getBoundingClientRect();
        const actualVideoWidth = elements.videoPlayer.videoWidth;
        const actualVideoHeight = elements.videoPlayer.videoHeight;
        const scaleX = videoRect.width / actualVideoWidth;
        const scaleY = videoRect.height / actualVideoHeight;
        
        // Get values in actual resolution
        let newWidth = parseInt(document.getElementById('cropWidth').value);
        let newHeight = parseInt(document.getElementById('cropHeight').value);
        let newX = parseInt(document.getElementById('cropX').value);
        let newY = parseInt(document.getElementById('cropY').value);
        
        // Convert actual resolution values to display values
        newWidth = Math.round(newWidth * scaleX);
        newHeight = Math.round(newHeight * scaleY);
        newX = Math.round(newX * scaleX);
        newY = Math.round(newY * scaleY);
        
        // Validate dimensions (in display coordinates)
        newWidth = Math.min(Math.max(50, newWidth), videoRect.width);
        newHeight = Math.min(Math.max(50, newHeight), videoRect.height);
        newX = Math.min(Math.max(0, newX), videoRect.width - newWidth);
        newY = Math.min(Math.max(0, newY), videoRect.height - newHeight);
        
        // Apply new dimensions
        cropBox.style.width = `${newWidth}px`;
        cropBox.style.height = `${newHeight}px`;
        cropBox.style.left = `${newX}px`;
        cropBox.style.top = `${newY}px`;
        
        // Update crop dimensions and display
        updateCropDimensions();
        updateDimensionsDisplay();
    }

    // Update existing functions to include dimensions display updates
    function handleDragging(e) {
        if (!isDragging) return;
        
        const videoRect = elements.videoPlayer.getBoundingClientRect();
        const cropRect = cropBox.getBoundingClientRect();
        const overlayRect = elements.cropOverlay.getBoundingClientRect();
        
        let newLeft = e.clientX - overlayRect.left - dragStart.x;
        let newTop = e.clientY - overlayRect.top - dragStart.y;
        
        // Constrain to video boundaries
        newLeft = Math.max(0, Math.min(newLeft, videoRect.width - cropRect.width));
        newTop = Math.max(0, Math.min(newTop, videoRect.height - cropRect.height));
        
        cropBox.style.left = `${newLeft}px`;
        cropBox.style.top = `${newTop}px`;
        
        if (cropSettingsVisible) {
            updateDimensionsDisplay();
        }
    }

    function handleResizing(e) {
        if (!isResizing) return;
        
        const videoRect = elements.videoPlayer.getBoundingClientRect();
        const overlayRect = elements.cropOverlay.getBoundingClientRect();
        const deltaX = e.clientX - dragStart.x;
        const deltaY = e.clientY - dragStart.y;
        
        let newBox = {
            left: originalBox.left - overlayRect.left,
            top: originalBox.top - overlayRect.top,
            width: originalBox.width,
            height: originalBox.height
        };
        
        // Handle different resize directions
        switch (resizeHandle) {
            case 'nw':
                newBox.left += deltaX;
                newBox.top += deltaY;
                newBox.width -= deltaX;
                newBox.height -= deltaY;
                break;
            case 'n':
                newBox.top += deltaY;
                newBox.height -= deltaY;
                break;
            case 'ne':
                newBox.width += deltaX;
                newBox.top += deltaY;
                newBox.height -= deltaY;
                break;
            case 'w':
                newBox.left += deltaX;
                newBox.width -= deltaX;
                break;
            case 'e':
                newBox.width += deltaX;
                break;
            case 'sw':
                newBox.left += deltaX;
                newBox.width -= deltaX;
                newBox.height += deltaY;
                break;
            case 's':
                newBox.height += deltaY;
                break;
            case 'se':
                newBox.width += deltaX;
                newBox.height += deltaY;
                break;
        }
        
        // Apply minimum size constraint
        if (newBox.width < 50) {
            if (resizeHandle.includes('w')) {
                newBox.left = newBox.left + newBox.width - 50;
            }
            newBox.width = 50;
        }
        if (newBox.height < 50) {
            if (resizeHandle.includes('n')) {
                newBox.top = newBox.top + newBox.height - 50;
            }
            newBox.height = 50;
        }
        
        // Apply boundary constraints
        if (newBox.left < 0) {
            if (resizeHandle.includes('w')) {
                newBox.width += newBox.left;
            }
            newBox.left = 0;
        }
        if (newBox.top < 0) {
            if (resizeHandle.includes('n')) {
                newBox.height += newBox.top;
            }
            newBox.top = 0;
        }
        if (newBox.left + newBox.width > videoRect.width) {
            newBox.width = videoRect.width - newBox.left;
        }
        if (newBox.top + newBox.height > videoRect.height) {
            newBox.height = videoRect.height - newBox.top;
        }
        
        // Update crop box
        cropBox.style.left = `${newBox.left}px`;
        cropBox.style.top = `${newBox.top}px`;
        cropBox.style.width = `${newBox.width}px`;
        cropBox.style.height = `${newBox.height}px`;
        
        if (cropSettingsVisible) {
            updateDimensionsDisplay();
        }
    }

    function startDragging(e) {
        if (e.target.classList.contains('crop-handle')) return;
        
        isDragging = true;
        const rect = cropBox.getBoundingClientRect();
        const overlayRect = elements.cropOverlay.getBoundingClientRect();
        dragStart = {
            x: e.clientX - overlayRect.left - (rect.left - overlayRect.left),
            y: e.clientY - overlayRect.top - (rect.top - overlayRect.top)
        };
        e.preventDefault();
    }

    function startResizing(e) {
        isResizing = true;
        resizeHandle = e.target.className.split(' ')[1];
        const rect = cropBox.getBoundingClientRect();
        originalBox = {
            left: rect.left,
            top: rect.top,
            width: rect.width,
            height: rect.height
        };
        dragStart = {
            x: e.clientX,
            y: e.clientY
        };
        e.stopPropagation();
        e.preventDefault();
    }

    function stopDragging() {
        isDragging = false;
        updateCropDimensions();
    }

    function stopResizing() {
        isResizing = false;
        resizeHandle = null;
        updateCropDimensions();
    }

    // Updated updateCropDimensions function with rounding to 4 decimals
    function updateCropDimensions() {
        const videoRect = elements.videoPlayer.getBoundingClientRect();
        const boxRect = cropBox.getBoundingClientRect();
        
        cropDimensions = {
            x: parseFloat((((boxRect.left - videoRect.left) / videoRect.width)).toFixed(4)),
            y: parseFloat((((boxRect.top - videoRect.top) / videoRect.height)).toFixed(4)),
            width: parseFloat(((boxRect.width / videoRect.width)).toFixed(4)),
            height: parseFloat(((boxRect.height / videoRect.height)).toFixed(4))
        };
    }

    function removeCropOverlay() {
        // Store the current crop dimensions based on cropBox before removing
        if (cropBox) {
            const videoRect = elements.videoPlayer.getBoundingClientRect();
            const boxRect = cropBox.getBoundingClientRect();
            lastCropDimensions = {
                x: parseFloat(((boxRect.left - videoRect.left) / videoRect.width).toFixed(4)),
                y: parseFloat(((boxRect.top - videoRect.top) / videoRect.height).toFixed(4)),
                width: parseFloat((boxRect.width / videoRect.width).toFixed(4)),
                height: parseFloat((boxRect.height / videoRect.height).toFixed(4))
            };
        }
        elements.cropOverlay.style.display = 'none';
        elements.cropOverlay.innerHTML = '';
        cropBox = null;
        cropDimensions = null;
    }

    // Add event listeners for resize and drag
    document.addEventListener('mousemove', (e) => {
        if (isDragging) handleDragging(e);
        if (isResizing) handleResizing(e);
    });

    document.addEventListener('mouseup', () => {
        if (isDragging) stopDragging();
        if (isResizing) stopResizing();
    });

    function getTagIndexFromKey(key) {
        key = key.toUpperCase();
        if (key >= '1' && key <= '9') {
            return parseInt(key) - 1;
        } else if (key === '0') {
            return 9;
        } else if (key >= 'A' && key <= 'Z') {
            return 10 + (key.charCodeAt(0) - 'A'.charCodeAt(0));
        } else {
            return null;
        }
    }

    function getShortcutDisplay(index) {
        if (index < 9) return (index + 1).toString();
        else if (index === 9) return '0';
        else {
            let code = 'A'.charCodeAt(0) + (index - 10);
            if (code <= 'Z'.charCodeAt(0)) {
                return String.fromCharCode(code);
            } else {
                return ''; // No shortcut available if out of range
            }
        }
    }

    // After Settings Modal event listeners, add Tag Manager Modal event listeners

    let tagManagerMouseDownTarget = null;
    elements.tagManagerModal.addEventListener('mousedown', (event) => {
        tagManagerMouseDownTarget = event.target;
    });

    elements.tagManagerModal.addEventListener('mouseup', (event) => {
        if (tagManagerMouseDownTarget === elements.tagManagerModal && event.target === elements.tagManagerModal) {
            closeTagManager();
        }
    });

})();

</script>
</body>
</html>

